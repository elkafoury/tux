
/*******************************************************************************
 *  * JavaJACK - A JACK bridge for Java.
 *  *     Copyright (C) 2011  Chuck Ritola
 *  * 	chuck@ritolaaudio.com 
 * *	...with parts generated by JNAerator, where noted.
 *  * 
 *  *     This program is free software: you can redistribute it and/or modify
 *  *     it under the terms of the GNU General Public License as published by
 *  *     the Free Software Foundation, either version 3 of the License, or
 *  *     (at your option) any later version.
 *  * 
 *  *     This program is distributed in the hope that it will be useful,
 *  *     but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  *     GNU General Public License for more details.
 *  * 
 *  *     You should have received a copy of the GNU General Public License
 *  *     along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *  ******************************************************************************/
package com.ritolaaudio.jack;
import com.ochafik.lang.jnaerator.runtime.Structure;
/**
 * <i>native declaration : ./jack/types.h</i><br>
 * This file was autogenerated by <a href="http://jnaerator.googlecode.com/">JNAerator</a>,<br>
 * a tool written by <a href="http://ochafik.free.fr/">Olivier Chafik</a> that <a href="http://code.google.com/p/jnaerator/wiki/CreditsAndLicense">uses a few opensource projects.</a>.<br>
 * For help, please visit <a href="http://nativelibs4java.googlecode.com/">NativeLibs4Java</a> , <a href="http://rococoa.dev.java.net/">Rococoa</a>, or <a href="http://jna.dev.java.net/">JNA</a>.
 */
public class jack_position_t extends Structure<jack_position_t, jack_position_t.ByValue, jack_position_t.ByReference > {
	/**
	 * these four cannot be set from clients: the server sets them<br>
	 * < unique ID<br>
	 * C type : jack_unique_t
	 */
	public long unique_1;
	/// < monotonic, free-rolling
	public long usecs;
	/// < current frame rate (per second)
	public int frame_rate;
	/// < frame number, always present
	public int frame;
	/**
	 * < which other fields are valid<br>
	 * C type : jack_position_bits_t
	 */
	public int valid;
	/**
	 * JackPositionBBT fields:<br>
	 * < current bar
	 */
	public int bar;
	/// < current beat-within-bar
	public int beat;
	/// < current tick-within-beat
	public int tick;
	public double bar_start_tick;
	/// < time signature "numerator"
	public float beats_per_bar;
	/// < time signature "denominator"
	public float beat_type;
	public double ticks_per_beat;
	public double beats_per_minute;
	/**
	 * JackPositionTimecode fields:     (EXPERIMENTAL: could change)<br>
	 * < current time in seconds
	 */
	public double frame_time;
	/**
	 * < next sequential frame_time<br>
	 * (unless repositioned)
	 */
	public double next_time;
	/**
	 * JackBBTFrameOffset fields:<br>
	 * < frame offset for the BBT fields<br>
	 * (the given bar, beat, and tick<br>
	 * values actually refer to a time<br>
	 * frame_offset frames before the<br>
	 * start of the cycle), should<br>
	 * be assumed to be 0 if<br>
	 * JackBBTFrameOffset is not<br>
	 * set. If JackBBTFrameOffset is<br>
	 * set and this value is zero, the BBT<br>
	 * time refers to the first frame of this<br>
	 * cycle. If the value is positive,<br>
	 * the BBT time refers to a frame that<br>
	 * many frames before the start of the<br>
	 * cycle.
	 */
	public int bbt_offset;
	/**
	 * < number of audio frames<br>
	 * per video frame. Should be assumed<br>
	 * zero if JackAudioVideoRatio is not<br>
	 * set. If JackAudioVideoRatio is set<br>
	 * and the value is zero, no video<br>
	 * data exists within the JACK graph
	 */
	public float audio_frames_per_video_frame;
	/**
	 * < audio frame at which the first video<br>
	 * frame in this cycle occurs. Should<br>
	 * be assumed to be 0 if JackVideoFrameOffset<br>
	 * is not set. If JackVideoFrameOffset is<br>
	 * set, but the value is zero, there is<br>
	 * no video frame within this cycle.
	 */
	public int video_offset;
	/**
	 * For binary compatibility, new fields should be allocated from<br>
	 * this padding area with new valid bits controlling access, so<br>
	 * the existing structure size and offsets are preserved.<br>
	 * C type : int32_t[7]
	 */
	public int[] padding = new int[(7)];
	/**
	 * When (unique_1 == unique_2) the contents are consistent.<br>
	 * < unique ID<br>
	 * C type : jack_unique_t
	 */
	public long unique_2;
	public jack_position_t() {
		super();
		initFieldOrder();
	}
	protected void initFieldOrder() {
		setFieldOrder(new java.lang.String[]{"unique_1", "usecs", "frame_rate", "frame", "valid", "bar", "beat", "tick", "bar_start_tick", "beats_per_bar", "beat_type", "ticks_per_beat", "beats_per_minute", "frame_time", "next_time", "bbt_offset", "audio_frames_per_video_frame", "video_offset", "padding", "unique_2"});
	}
	protected ByReference newByReference() { return new ByReference(); }
	protected ByValue newByValue() { return new ByValue(); }
	protected jack_position_t newInstance() { return new jack_position_t(); }
	public static jack_position_t[] newArray(int arrayLength) {
		return Structure.newArray(jack_position_t.class, arrayLength);
	}
	public static class ByReference extends jack_position_t implements Structure.ByReference {
		
	};
	public static class ByValue extends jack_position_t implements Structure.ByValue {
		
	};
}
