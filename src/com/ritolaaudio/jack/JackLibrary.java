
/*******************************************************************************
 *  * JavaJACK - A JACK bridge for Java.
 *  *     Copyright (C) 2011  Chuck Ritola
 *  * 	chuck@ritolaaudio.com 
 * *	...with parts generated by JNAerator, where noted.
 *  * 
 *  *     This program is free software: you can redistribute it and/or modify
 *  *     it under the terms of the GNU General Public License as published by
 *  *     the Free Software Foundation, either version 3 of the License, or
 *  *     (at your option) any later version.
 *  * 
 *  *     This program is distributed in the hope that it will be useful,
 *  *     but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  *     GNU General Public License for more details.
 *  * 
 *  *     You should have received a copy of the GNU General Public License
 *  *     along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *  ******************************************************************************/
package com.ritolaaudio.jack;
import com.ochafik.lang.jnaerator.runtime.LibraryExtractor;
import com.ochafik.lang.jnaerator.runtime.Mangling;
import com.ochafik.lang.jnaerator.runtime.NativeSize;
import com.ochafik.lang.jnaerator.runtime.globals.GlobalCallback;
import com.sun.jna.Callback;
import com.sun.jna.Library;
import com.sun.jna.Native;
import com.sun.jna.NativeLibrary;
import com.sun.jna.NativeLong;
import com.sun.jna.Pointer;
import com.sun.jna.ptr.IntByReference;
import com.sun.jna.ptr.PointerByReference;
import java.nio.ByteBuffer;
import java.nio.IntBuffer;

import javax.naming.NameNotFoundException;
/**
 * JNA Wrapper for library <b>jack</b><br>
 * This file was autogenerated by <a href="http://jnaerator.googlecode.com/">JNAerator</a>,<br>
 * a tool written by <a href="http://ochafik.free.fr/">Olivier Chafik</a> that <a href="http://code.google.com/p/jnaerator/wiki/CreditsAndLicense">uses a few opensource projects.</a>.<br>
 * For help, please visit <a href="http://nativelibs4java.googlecode.com/">NativeLibs4Java</a> , <a href="http://rococoa.dev.java.net/">Rococoa</a>, or <a href="http://jna.dev.java.net/">JNA</a>.
 */
public interface JackLibrary extends Library {
	public static final String JNA_LIBRARY_NAME = LibraryExtractor.getLibraryPath("jack", true, JackLibrary.class);
	public static final NativeLibrary JNA_NATIVE_LIB = NativeLibrary.getInstance(JackLibrary.JNA_LIBRARY_NAME, com.ochafik.lang.jnaerator.runtime.MangledFunctionMapper.DEFAULT_OPTIONS);
	public static final JackLibrary INSTANCE = (JackLibrary)Native.loadLibrary(JackLibrary.JNA_LIBRARY_NAME, JackLibrary.class, com.ochafik.lang.jnaerator.runtime.MangledFunctionMapper.DEFAULT_OPTIONS);
	/**
	 * @ref jack_options_t bits<br>
	 * <i>native declaration : ./jack/types.h:79</i><br>
	 * enum values
	 */
	public static interface JackOptions {
		/**
		 * Null value to use when no option bits are needed.<br>
		 * Null value to use when no option bits are needed.<br>
		 * <i>native declaration : ./jack/types.h:84</i>
		 */
		public static final int JackNullOption = (int)0;
		/**
		 * Do not automatically start the JACK server when it is not<br>
		 * already running.  This option is always selected if<br>
		 * \$JACK_NO_START_SERVER is defined in the calling process<br>
		 * environment.<br>
		 * Do not automatically start the JACK server when it is not<br>
		 * already running.  This option is always selected if<br>
		 * \$JACK_NO_START_SERVER is defined in the calling process<br>
		 * environment.<br>
		 * <i>native declaration : ./jack/types.h:92</i>
		 */
		public static final int JackNoStartServer = (int)1;
		/**
		 * Use the exact client name requested.  Otherwise, JACK<br>
		 * automatically generates a unique one, if needed.<br>
		 * Use the exact client name requested.  Otherwise, JACK<br>
		 * automatically generates a unique one, if needed.<br>
		 * <i>native declaration : ./jack/types.h:98</i>
		 */
		public static final int JackUseExactName = (int)2;
		/**
		 * Open with optional <em>(char *) server_name</em> parameter.<br>
		 * Open with optional <em>(char *) server_name</em> parameter.<br>
		 * <i>native declaration : ./jack/types.h:103</i>
		 */
		public static final int JackServerName = (int)4;
		/**
		 * Load internal client from optional <em>(char *)<br>
		 * load_name</em>.  Otherwise use the @a client_name.<br>
		 * Load internal client from optional <em>(char *)<br>
		 * load_name</em>.  Otherwise use the @a client_name.<br>
		 * <i>native declaration : ./jack/types.h:109</i>
		 */
		public static final int JackLoadName = (int)8;
		/**
		 * Pass optional <em>(char *) load_init</em> string to the<br>
		 * jack_initialize() entry point of an internal client.<br>
		 * Pass optional <em>(char *) load_init</em> string to the<br>
		 * jack_initialize() entry point of an internal client.<br>
		 * <i>native declaration : ./jack/types.h:115</i>
		 */
		public static final int JackLoadInit = (int)16;
		/**
		 * pass a SessionID Token this allows the sessionmanager to identify the client again.<br>
		 * pass a SessionID Token this allows the sessionmanager to identify the client again.<br>
		 * <i>native declaration : ./jack/types.h:120</i>
		 */
		public static final int JackSessionID = (int)32;
	};
	/**
	 * @ref jack_status_t bits<br>
	 * <i>native declaration : ./jack/types.h:138</i><br>
	 * enum values
	 */
	public static interface JackStatus {
		/**
		 * Overall operation failed.<br>
		 * Overall operation failed.<br>
		 * <i>native declaration : ./jack/types.h:143</i>
		 */
		public static final int JackFailure = (int)1;
		/**
		 * The operation contained an invalid or unsupported option.<br>
		 * The operation contained an invalid or unsupported option.<br>
		 * <i>native declaration : ./jack/types.h:148</i>
		 */
		public static final int JackInvalidOption = (int)2;
		/**
		 * The desired client name was not unique.  With the @ref<br>
		 * JackUseExactName option this situation is fatal.  Otherwise,<br>
		 * the name was modified by appending a dash and a two-digit<br>
		 * number in the range "-01" to "-99".  The<br>
		 * jack_get_client_name() function will return the exact string<br>
		 * that was used.  If the specified @a client_name plus these<br>
		 * extra characters would be too long, the open fails instead.<br>
		 * The desired client name was not unique.  With the @ref<br>
		 * JackUseExactName option this situation is fatal.  Otherwise,<br>
		 * the name was modified by appending a dash and a two-digit<br>
		 * number in the range "-01" to "-99".  The<br>
		 * jack_get_client_name() function will return the exact string<br>
		 * that was used.  If the specified @a client_name plus these<br>
		 * extra characters would be too long, the open fails instead.<br>
		 * <i>native declaration : ./jack/types.h:159</i>
		 */
		public static final int JackNameNotUnique = (int)4;
		/**
		 * The JACK server was started as a result of this operation.<br>
		 * Otherwise, it was running already.  In either case the caller<br>
		 * is now connected to jackd, so there is no race condition.<br>
		 * When the server shuts down, the client will find out.<br>
		 * The JACK server was started as a result of this operation.<br>
		 * Otherwise, it was running already.  In either case the caller<br>
		 * is now connected to jackd, so there is no race condition.<br>
		 * When the server shuts down, the client will find out.<br>
		 * <i>native declaration : ./jack/types.h:167</i>
		 */
		public static final int JackServerStarted = (int)8;
		/**
		 * Unable to connect to the JACK server.<br>
		 * Unable to connect to the JACK server.<br>
		 * <i>native declaration : ./jack/types.h:172</i>
		 */
		public static final int JackServerFailed = (int)16;
		/**
		 * Communication error with the JACK server.<br>
		 * Communication error with the JACK server.<br>
		 * <i>native declaration : ./jack/types.h:177</i>
		 */
		public static final int JackServerError = (int)32;
		/**
		 * Requested client does not exist.<br>
		 * Requested client does not exist.<br>
		 * <i>native declaration : ./jack/types.h:182</i>
		 */
		public static final int JackNoSuchClient = (int)64;
		/**
		 * Unable to load internal client<br>
		 * Unable to load internal client<br>
		 * <i>native declaration : ./jack/types.h:187</i>
		 */
		public static final int JackLoadFailure = (int)128;
		/**
		 * Unable to initialize client<br>
		 * Unable to initialize client<br>
		 * <i>native declaration : ./jack/types.h:192</i>
		 */
		public static final int JackInitFailure = (int)256;
		/**
		 * Unable to access shared memory<br>
		 * Unable to access shared memory<br>
		 * <i>native declaration : ./jack/types.h:197</i>
		 */
		public static final int JackShmFailure = (int)512;
		/**
		 * Client's protocol version does not match<br>
		 * Client's protocol version does not match<br>
		 * <i>native declaration : ./jack/types.h:202</i>
		 */
		public static final int JackVersionError = (int)1024;
		/**
		 * Backend error<br>
		 * Backend error<br>
		 * <i>native declaration : ./jack/types.h:207</i>
		 */
		public static final int JackBackendError = (int)2048;
		/**
		 * Client zombified failure<br>
		 * Client zombified failure<br>
		 * <i>native declaration : ./jack/types.h:212</i>
		 */
		public static final int JackClientZombie = (int)4096;
	};
	/**
	 * @ref jack_latency_callback_mode_t<br>
	 * <i>native declaration : ./jack/types.h:224</i><br>
	 * enum values
	 */
	public static interface JackLatencyCallbackMode {
		/**
		 * Latency Callback for Capture Latency.<br>
		 * Input Ports have their latency value setup.<br>
		 * In the Callback the client needs to set the latency of the output ports<br>
		 * Latency Callback for Capture Latency.<br>
		 * Input Ports have their latency value setup.<br>
		 * In the Callback the client needs to set the latency of the output ports<br>
		 * <i>native declaration : ./jack/types.h:231</i>
		 */
		public static final int JackCaptureLatency = (int)0;
		/**
		 * Latency Callback for Playback Latency.<br>
		 * Output Ports have their latency value setup.<br>
		 * In the Callback the client needs to set the latency of the input ports<br>
		 * Latency Callback for Playback Latency.<br>
		 * Output Ports have their latency value setup.<br>
		 * In the Callback the client needs to set the latency of the input ports<br>
		 * <i>native declaration : ./jack/types.h:238</i>
		 */
		public static final int JackPlaybackLatency = (int)1;
	};
	/**
	 * A port has a set of flags that are formed by AND-ing together the<br>
	 *  desired values from the list below. The flags "JackPortIsInput" and<br>
	 *  "JackPortIsOutput" are mutually exclusive and it is an error to use<br>
	 *  them both.<br>
	 * <i>native declaration : ./jack/types.h:464</i><br>
	 * enum values
	 */
	public static interface JackPortFlags {
		/**
		 * if JackPortIsInput is set, then the port can receive<br>
		 * data.<br>
		 * if JackPortIsInput is set, then the port can receive<br>
		 * data.<br>
		 * <i>native declaration : ./jack/types.h:470</i>
		 */
		public static final int JackPortIsInput = (int)1;
		/**
		 * if JackPortIsOutput is set, then data can be read from<br>
		 * the port.<br>
		 * if JackPortIsOutput is set, then data can be read from<br>
		 * the port.<br>
		 * <i>native declaration : ./jack/types.h:476</i>
		 */
		public static final int JackPortIsOutput = (int)2;
		/**
		 * if JackPortIsPhysical is set, then the port corresponds<br>
		 * to some kind of physical I/O connector.<br>
		 * if JackPortIsPhysical is set, then the port corresponds<br>
		 * to some kind of physical I/O connector.<br>
		 * <i>native declaration : ./jack/types.h:482</i>
		 */
		public static final int JackPortIsPhysical = (int)4;
		/**
		 * if JackPortCanMonitor is set, then a call to<br>
		 * jack_port_request_monitor() makes sense.<br>
		 * * Precisely what this means is dependent on the client. A typical<br>
		 * result of it being called with TRUE as the second argument is<br>
		 * that data that would be available from an output port (with<br>
		 * JackPortIsPhysical set) is sent to a physical output connector<br>
		 * as well, so that it can be heard/seen/whatever.<br>
		 * * Clients that do not control physical interfaces<br>
		 * should never create ports with this bit set.<br>
		 * if JackPortCanMonitor is set, then a call to<br>
		 * jack_port_request_monitor() makes sense.<br>
		 * * Precisely what this means is dependent on the client. A typical<br>
		 * result of it being called with TRUE as the second argument is<br>
		 * that data that would be available from an output port (with<br>
		 * JackPortIsPhysical set) is sent to a physical output connector<br>
		 * as well, so that it can be heard/seen/whatever.<br>
		 * * Clients that do not control physical interfaces<br>
		 * should never create ports with this bit set.<br>
		 * <i>native declaration : ./jack/types.h:497</i>
		 */
		public static final int JackPortCanMonitor = (int)8;
		/**
		 * JackPortIsTerminal means:<br>
		 * *  for an input port: the data received by the port<br>
		 *                    will not be passed on or made<br>
		 *                     available at any other port<br>
		 * * for an output port: the data available at the port<br>
		 *                    does not originate from any other port<br>
		 * * Audio synthesizers, I/O hardware interface clients, HDR<br>
		 * systems are examples of clients that would set this flag for<br>
		 * their ports.<br>
		 * JackPortIsTerminal means:<br>
		 * *  for an input port: the data received by the port<br>
		 *                    will not be passed on or made<br>
		 *                     available at any other port<br>
		 * * for an output port: the data available at the port<br>
		 *                    does not originate from any other port<br>
		 * * Audio synthesizers, I/O hardware interface clients, HDR<br>
		 * systems are examples of clients that would set this flag for<br>
		 * their ports.<br>
		 * <i>native declaration : ./jack/types.h:513</i>
		 */
		public static final int JackPortIsTerminal = (int)16;
	};
	/**
	 * <i>native declaration : ./jack/types.h</i><br>
	 * enum values
	 */
	public static interface jack_transport_state_t {
		/**
		 * the order matters for binary compatibility<br>
		 * the order matters for binary compatibility<br>
		 * < Transport halted<br>
		 * <i>native declaration : ./jack/types.h:523</i>
		 */
		public static final int JackTransportStopped = (int)0;
		/**
		 * < Transport playing<br>
		 * <i>native declaration : ./jack/types.h:524</i>
		 */
		public static final int JackTransportRolling = (int)1;
		/**
		 * < For OLD_TRANSPORT, now ignored<br>
		 * <i>native declaration : ./jack/types.h:525</i>
		 */
		public static final int JackTransportLooping = (int)2;
		/**
		 * < Waiting for sync ready<br>
		 * <i>native declaration : ./jack/types.h:526</i>
		 */
		public static final int JackTransportStarting = (int)3;
		/**
		 * < Waiting for sync ready on the network<br>
		 * <i>native declaration : ./jack/types.h:527</i>
		 */
		public static final int JackTransportNetStarting = (int)4;
	};
	/**
	 * <i>native declaration : ./jack/types.h</i><br>
	 * enum values
	 */
	public static interface jack_position_bits_t {
		/**
		 * < Bar, Beat, Tick<br>
		 * <i>native declaration : ./jack/types.h:538</i>
		 */
		public static final int JackPositionBBT = (int)16;
		/**
		 * < External timecode<br>
		 * <i>native declaration : ./jack/types.h:539</i>
		 */
		public static final int JackPositionTimecode = (int)32;
		/**
		 * < Frame offset of BBT information<br>
		 * <i>native declaration : ./jack/types.h:540</i>
		 */
		public static final int JackBBTFrameOffset = (int)64;
		/**
		 * < audio frames per video frame<br>
		 * <i>native declaration : ./jack/types.h:541</i>
		 */
		public static final int JackAudioVideoRatio = (int)128;
		/**
		 * < frame offset of first video frame<br>
		 * <i>native declaration : ./jack/types.h:542</i>
		 */
		public static final int JackVideoFrameOffset = (int)256;
	};
	/**
	 * <i>native declaration : ./jack/types.h</i><br>
	 * enum values
	 */
	public static interface jack_transport_bits_t {
		/**
		 * < Transport state<br>
		 * <i>native declaration : ./jack/types.h:691</i>
		 */
		public static final int JackTransportState = (int)1;
		/**
		 * < Frame number<br>
		 * <i>native declaration : ./jack/types.h:692</i>
		 */
		public static final int JackTransportPosition = (int)2;
		/**
		 * < Loop boundaries (ignored)<br>
		 * <i>native declaration : ./jack/types.h:693</i>
		 */
		public static final int JackTransportLoop = (int)4;
		/**
		 * < SMPTE (ignored)<br>
		 * <i>native declaration : ./jack/types.h:694</i>
		 */
		public static final int JackTransportSMPTE = (int)8;
		/**
		 * < Bar, Beat, Tick<br>
		 * <i>native declaration : ./jack/types.h:695</i>
		 */
		public static final int JackTransportBBT = (int)16;
	};
	/**
	 * Session event type.<br>
	 * * if a client cant save templates, i might just do a normal save.<br>
	 * * There is no "quit without saving" event because a client might refuse to<br>
	 * quit when it has unsaved data, but other clients may have already quit.<br>
	 * This results in too much confusion, so it is unsupported.<br>
	 * <i>native declaration : jack/session.h:43</i><br>
	 * enum values
	 */
	public static interface JackSessionEventType {
		/**
		 * Save the session completely.<br>
		 * * The client may save references to data outside the provided directory,<br>
		 * but it must do so by creating a link inside the provided directory and<br>
		 * referring to that in any save files. The client must not refer to data<br>
		 * files outside the provided directory directly in save files, because<br>
		 * this makes it impossible for the session manager to create a session<br>
		 * archive for distribution or archival.<br>
		 * Save the session completely.<br>
		 * * The client may save references to data outside the provided directory,<br>
		 * but it must do so by creating a link inside the provided directory and<br>
		 * referring to that in any save files. The client must not refer to data<br>
		 * files outside the provided directory directly in save files, because<br>
		 * this makes it impossible for the session manager to create a session<br>
		 * archive for distribution or archival.<br>
		 * <i>native declaration : jack/session.h:54</i>
		 */
		public static final int JackSessionSave = (int)1;
		/**
		 * Save the session completly, then quit.<br>
		 * * The rules for saving are exactly the same as for JackSessionSave.<br>
		 * Save the session completly, then quit.<br>
		 * * The rules for saving are exactly the same as for JackSessionSave.<br>
		 * <i>native declaration : jack/session.h:61</i>
		 */
		public static final int JackSessionSaveAndQuit = (int)2;
		/**
		 * Save a session template.<br>
		 * * A session template is a "skeleton" of the session, but without any data.<br>
		 * Clients must save a session that, when restored, will create the same<br>
		 * ports as a full save would have. However, the actual data contained in<br>
		 * the session may not be saved (e.g. a DAW would create the necessary<br>
		 * tracks, but not save the actual recorded data).<br>
		 * Save a session template.<br>
		 * * A session template is a "skeleton" of the session, but without any data.<br>
		 * Clients must save a session that, when restored, will create the same<br>
		 * ports as a full save would have. However, the actual data contained in<br>
		 * the session may not be saved (e.g. a DAW would create the necessary<br>
		 * tracks, but not save the actual recorded data).<br>
		 * <i>native declaration : jack/session.h:72</i>
		 */
		public static final int JackSessionSaveTemplate = (int)3;
	};
	/**
	 * @ref jack_session_flags_t bits<br>
	 * <i>native declaration : jack/session.h:80</i><br>
	 * enum values
	 */
	public static interface JackSessionFlags {
		/**
		 * An error occured while saving.<br>
		 * An error occured while saving.<br>
		 * <i>native declaration : jack/session.h:84</i>
		 */
		public static final int JackSessionSaveError = (int)1;
		/**
		 * Client needs to be run in a terminal.<br>
		 * Client needs to be run in a terminal.<br>
		 * <i>native declaration : jack/session.h:89</i>
		 */
		public static final int JackSessionNeedTerminal = (int)2;
	};
	/**
	 * <i>native declaration : jack/control.h</i><br>
	 * enum values
	 */
	public static interface jackctl_param_type_t {
		/**
		 * < @brief value type is a signed integer<br>
		 * <i>native declaration : jack/control.h:40</i>
		 */
		public static final int JackParamInt = (int)1;
		/**
		 * < @brief value type is an unsigned integer<br>
		 * <i>native declaration : jack/control.h:41</i>
		 */
		public static final int JackParamUInt = (int)2;
		/**
		 * < @brief value type is a char<br>
		 * <i>native declaration : jack/control.h:42</i>
		 */
		public static final int JackParamChar = (int)3;
		/**
		 * < @brief value type is a string with max size of ::JACK_PARAM_STRING_MAX+1 chars<br>
		 * <i>native declaration : jack/control.h:43</i>
		 */
		public static final int JackParamString = (int)4;
		/**
		 * < @brief value type is a boolean<br>
		 * <i>native declaration : jack/control.h:44</i>
		 */
		public static final int JackParamBool = (int)5;
	};
	/// <i>native declaration : ./jack/types.h</i>
	public static final long JACK_MAX_FRAMES = (long)(4294967295L);
	/// <i>native declaration : ./jack/types.h</i>
	public static final int JACK_LOAD_INIT_LIMIT = (int)1024;
	/// <i>native declaration : jack/thread.h</i>
	public static final int THREAD_STACK = (int)524288;
	/// <i>native declaration : ./jack/types.h</i>
	public static final String JACK_DEFAULT_MIDI_TYPE = (String)"8 bit raw midi";
	/// <i>native declaration : jack/control.h</i>
	public static final int JACK_PARAM_STRING_MAX = (int)127;
	/// <i>native declaration : ./jack/types.h</i>
	public static final String JACK_DEFAULT_AUDIO_TYPE = (String)"32 bit float mono audio";
	/// <i>native declaration : jack/thread.h</i>
	public interface jack_thread_creator_t extends Callback {
		int apply(IntByReference pthread_tPtr1, Pointer pthread_attr_tPtr1, JackLibrary.jack_thread_creator_t_arg1_function_callback arg1, Pointer arg);
	};
	/// <i>native declaration : jack/thread.h:0</i>
	public interface jack_client_create_thread_arg1_start_routine_callback extends Callback {
		Pointer apply(Pointer voidPtr1);
	};
	/// <i>native declaration : jack/thread.h:0</i>
	public interface jack_thread_creator_t_arg1_function_callback extends Callback {
		Pointer apply(Pointer voidPtr1);
	};
	/**
	 * Prototype for the client supplied function that is called<br>
	 * by the engine when port latencies need to be recalculated<br>
	 * * @param mode playback or capture latency<br>
	 * @param arg pointer to a client supplied data<br>
	 * * @return zero on success, non-zero on error<br>
	 * <i>native declaration : ./jack/types.h</i>
	 */
	public interface JackLatencyCallback extends Callback {
		/// @param mode @see jack_latency_callback_mode_t
		void apply(int mode, Pointer arg);
	};
	/**
	 * Prototype for the client supplied function that is called<br>
	 * by the engine anytime there is work to be done.<br>
	 * * @pre nframes == jack_get_buffer_size()<br>
	 * @pre nframes == pow(2,x)<br>
	 * * @param nframes number of frames to process<br>
	 * @param arg pointer to a client supplied structure<br>
	 * * @return zero on success, non-zero on error<br>
	 * <i>native declaration : ./jack/types.h</i>
	 */
	public interface JackProcessCallback extends Callback {
		int apply(int nframes, Pointer arg);
	};
	/**
	 * Prototype for the client thread routine called<br>
	 * by the engine when the client is inserted in the graph.<br>
	 * * @param arg pointer to a client supplied structure<br>
	 * <i>native declaration : ./jack/types.h:296</i>
	 */
	public interface JackThreadCallback extends Callback {
		Pointer apply(Pointer arg);
	};
	/**
	 * Prototype for the client supplied function that is called<br>
	 * once after the creation of the thread in which other<br>
	 * callbacks will be made. Special thread characteristics<br>
	 * can be set from this callback, for example. This is a<br>
	 * highly specialized callback and most clients will not<br>
	 * and should not use it.<br>
	 * * @param arg pointer to a client supplied structure<br>
	 * * @return void<br>
	 * <i>native declaration : ./jack/types.h</i>
	 */
	public interface JackThreadInitCallback extends Callback {
		void apply(Pointer arg);
	};
	/**
	 * Prototype for the client supplied function that is called<br>
	 * whenever the processing graph is reordered.<br>
	 * * @param arg pointer to a client supplied structure<br>
	 * * @return zero on success, non-zero on error<br>
	 * <i>native declaration : ./jack/types.h</i>
	 */
	public interface JackGraphOrderCallback extends Callback {
		int apply(Pointer arg);
	};
	/**
	 * Prototype for the client-supplied function that is called whenever<br>
	 * an xrun has occured.<br>
	 * * @see jack_get_xrun_delayed_usecs()<br>
	 * * @param arg pointer to a client supplied structure<br>
	 * * @return zero on success, non-zero on error<br>
	 * <i>native declaration : ./jack/types.h</i>
	 */
	public interface JackXRunCallback extends Callback {
		int apply(Pointer arg);
	};
	/**
	 * Prototype for the @a bufsize_callback that is invoked whenever the<br>
	 * JACK engine buffer size changes.  Although this function is called<br>
	 * in the JACK process thread, the normal process cycle is suspended<br>
	 * during its operation, causing a gap in the audio flow.  So, the @a<br>
	 * bufsize_callback can allocate storage, touch memory not previously<br>
	 * referenced, and perform other operations that are not realtime<br>
	 * safe.<br>
	 * * @param nframes buffer size<br>
	 * @param arg pointer supplied by jack_set_buffer_size_callback().<br>
	 * * @return zero on success, non-zero on error<br>
	 * <i>native declaration : ./jack/types.h</i>
	 */
	public interface JackBufferSizeCallback extends Callback {
		int apply(int nframes, Pointer arg);
	};
	/**
	 * Prototype for the client supplied function that is called<br>
	 * when the engine sample rate changes.<br>
	 * * @param nframes new engine sample rate<br>
	 * @param arg pointer to a client supplied structure<br>
	 * * @return zero on success, non-zero on error<br>
	 * <i>native declaration : ./jack/types.h</i>
	 */
	public interface JackSampleRateCallback extends Callback {
		int apply(int nframes, Pointer arg);
	};
	/**
	 * Prototype for the client supplied function that is called<br>
	 * whenever a port is registered or unregistered.<br>
	 * * @param port the ID of the port<br>
	 * @param arg pointer to a client supplied data<br>
	 * @param register non-zero if the port is being registered,<br>
	 *                     zero if the port is being unregistered<br>
	 * <i>native declaration : ./jack/types.h</i>
	 */
	public interface JackPortRegistrationCallback extends Callback {
		void apply(int port, int int1, Pointer arg);
	};
	/**
	 * Prototype for the client supplied function that is called<br>
	 * whenever a client is registered or unregistered.<br>
	 * * @param name a null-terminated string containing the client name<br>
	 * @param register non-zero if the client is being registered,<br>
	 *                     zero if the client is being unregistered<br>
	 * @param arg pointer to a client supplied structure<br>
	 * <i>native declaration : ./jack/types.h</i>
	 */
	public interface JackClientRegistrationCallback extends Callback {
		void apply(Pointer name, int int1, Pointer arg);
	};
	/**
	 * Prototype for the client supplied function that is called<br>
	 * whenever a port is connected or disconnected.<br>
	 * * @param a one of two ports connected or disconnected<br>
	 * @param b one of two ports connected or disconnected<br>
	 * @param connect non-zero if ports were connected<br>
	 *                    zero if ports were disconnected<br>
	 * @param arg pointer to a client supplied data<br>
	 * <i>native declaration : ./jack/types.h</i>
	 */
	public interface JackPortConnectCallback extends Callback {
		void apply(int a, int b, int connect, Pointer arg);
	};
	/**
	 * Prototype for the client supplied function that is called<br>
	 * whenever the port name has been changed.<br>
	 * * @param port the port that has been renamed<br>
	 * @param new_name the new name<br>
	 * @param arg pointer to a client supplied structure<br>
	 * * @return zero on success, non-zero on error<br>
	 * <i>native declaration : ./jack/types.h</i>
	 */
	public interface JackPortRenameCallback extends Callback {
		int apply(int port, Pointer old_name, Pointer new_name, Pointer arg) throws NameNotFoundException;
	};
	/**
	 * Prototype for the client supplied function that is called<br>
	 * whenever jackd starts or stops freewheeling.<br>
	 * * @param starting non-zero if we start starting to freewheel, zero otherwise<br>
	 * @param arg pointer to a client supplied structure<br>
	 * <i>native declaration : ./jack/types.h</i>
	 */
	public interface JackFreewheelCallback extends Callback {
		void apply(int starting, Pointer arg);
	};
	/**
	 * Prototype for the client supplied function that is called<br>
	 * whenever jackd is shutdown. Note that after server shutdown,<br>
	 * the client pointer is *not* deallocated by libjack,<br>
	 * the application is responsible to properly use jack_client_close()<br>
	 * to release client ressources. Warning: jack_client_close() cannot be<br>
	 * safely used inside the shutdown callback and has to be called outside of<br>
	 * the callback context.<br>
	 * * @param arg pointer to a client supplied structure<br>
	 * <i>native declaration : ./jack/types.h</i>
	 */
	public interface JackShutdownCallback extends Callback {
		void apply(Pointer arg);
	};
	/**
	 * Prototype for the client supplied function that is called<br>
	 * whenever jackd is shutdown. Note that after server shutdown,<br>
	 * the client pointer is *not* deallocated by libjack,<br>
	 * the application is responsible to properly use jack_client_close()<br>
	 * to release client ressources. Warning: jack_client_close() cannot be<br>
	 * safely used inside the shutdown callback and has to be called outside of<br>
	 * the callback context.<br>
	 * @param code a status word, formed by OR-ing together the relevant @ref JackStatus bits.<br>
	 * @param reason a string describing the shutdown reason (backend failure, server crash... etc...)<br>
	 * @param arg pointer to a client supplied structure<br>
	 * <i>native declaration : ./jack/types.h</i>
	 */
	public interface JackInfoShutdownCallback extends Callback {
		/// @param code @see jack_status_t
		void apply(int code, Pointer reason, Pointer arg);
	};
	/**
	 * Prototype for the @a sync_callback defined by slow-sync clients.<br>
	 * When the client is active, this callback is invoked just before<br>
	 * process() in the same thread.  This occurs once after registration,<br>
	 * then subsequently whenever some client requests a new position, or<br>
	 * the transport enters the ::JackTransportStarting state.  This<br>
	 * realtime function must not wait.<br>
	 * * The transport @a state will be:<br>
	 * *   - ::JackTransportStopped when a new position is requested;<br>
	 *   - ::JackTransportStarting when the transport is waiting to start;<br>
	 *   - ::JackTransportRolling when the timeout has expired, and the<br>
	 *   position is now a moving target.<br>
	 * * @param state current transport state.<br>
	 * @param pos new transport position.<br>
	 * @param arg the argument supplied by jack_set_sync_callback().<br>
	 * * @return TRUE (non-zero) when ready to roll.<br>
	 * <i>native declaration : ./jack/types.h</i>
	 */
	public interface JackSyncCallback extends Callback {
		int apply(int state, jack_position_t pos, Pointer arg);
	};
	/**
	 * Prototype for the @a timebase_callback used to provide extended<br>
	 * position information.  Its output affects all of the following<br>
	 * process cycle.  This realtime function must not wait.<br>
	 * * This function is called immediately after process() in the same<br>
	 * thread whenever the transport is rolling, or when any client has<br>
	 * requested a new position in the previous cycle.  The first cycle<br>
	 * after jack_set_timebase_callback() is also treated as a new<br>
	 * position, or the first cycle after jack_activate() if the client<br>
	 * had been inactive.<br>
	 * * The timebase master may not use its @a pos argument to set @a<br>
	 * pos->frame.  To change position, use jack_transport_reposition() or<br>
	 * jack_transport_locate().  These functions are realtime-safe, the @a<br>
	 * timebase_callback can call them directly.<br>
	 * * @param state current transport state.<br>
	 * @param nframes number of frames in current period.<br>
	 * @param pos address of the position structure for the next cycle; @a<br>
	 * pos->frame will be its frame number.  If @a new_pos is FALSE, this<br>
	 * structure contains extended position information from the current<br>
	 * cycle.  If TRUE, it contains whatever was set by the requester.<br>
	 * The @a timebase_callback's task is to update the extended<br>
	 * information here.<br>
	 * @param new_pos TRUE (non-zero) for a newly requested @a pos, or for<br>
	 * the first cycle after the @a timebase_callback is defined.<br>
	 * @param arg the argument supplied by jack_set_timebase_callback().<br>
	 * <i>native declaration : ./jack/types.h</i>
	 */
	public interface JackTimebaseCallback extends Callback {
		void apply(int state, int nframes, jack_position_t pos, int new_pos, Pointer arg);
	};
	/// <i>native declaration : jack/jslist.h</i>
	public interface JCompareFunc extends Callback {
		int apply(Pointer a, Pointer b);
	};
	/// <i>native declaration : jack/jack.h</i>
	public interface jack_error_callback_callback extends Callback {
		void apply(Pointer msg);
	};
	/// <i>native declaration : jack/jack.h:0</i>
	public interface jack_set_error_function_arg1_func_callback extends Callback {
		void apply(Pointer charPtr1);
	};
	/// <i>native declaration : jack/jack.h</i>
	public interface jack_info_callback_callback extends Callback {
		void apply(Pointer msg);
	};
	/// <i>native declaration : jack/jack.h:0</i>
	public interface jack_set_info_function_arg1_func_callback extends Callback {
		void apply(Pointer charPtr1);
	};
	/**
	 * Prototype for the client supplied function that is called<br>
	 * whenever a session notification is sent via jack_session_notify().<br>
	 * * Ownership of the memory of @a event is passed to the application.<br>
	 * It must be freed using jack_session_event_free when its not used anymore.<br>
	 * * The client must promptly call jack_session_reply for this event.<br>
	 * * @param event The event structure.<br>
	 * @param arg Pointer to a client supplied structure.<br>
	 * <i>native declaration : jack/session.h</i>
	 */
	public interface JackSessionCallback extends Callback {
		void apply(_jack_session_event event, Pointer arg);
	};
	/// <i>native declaration : jack/control.h:0</i>
	public interface jackctl_server_create_arg1_on_device_acquire_callback extends Callback {
		boolean apply(Pointer device_name);
	};
	/// <i>native declaration : jack/control.h:0</i>
	public interface jackctl_server_create_arg2_on_device_release_callback extends Callback {
		void apply(Pointer device_name);
	};
	/**
	 * Original signature : <code>int jack_client_real_time_priority(jack_client_t*)</code><br>
	 * <i>native declaration : jack/thread.h:50</i>
	 */
	@Mangling({"_Z30jack_client_real_time_priorityP12_jack_client", "?jack_client_real_time_priority@@YAHPA12_jack_client@Z"}) 
	int jack_client_real_time_priority(Pointer jack_client_tPtr1);
	/**
	 * Original signature : <code>int jack_client_max_real_time_priority(jack_client_t*)</code><br>
	 * <i>native declaration : jack/thread.h:58</i>
	 */
	@Mangling({"_Z34jack_client_max_real_time_priorityP12_jack_client", "?jack_client_max_real_time_priority@@YAHPA12_jack_client@Z"}) 
	int jack_client_max_real_time_priority(Pointer jack_client_tPtr1);
	/**
	 * Attempt to enable realtime scheduling for a thread.  On some<br>
	 * systems that may require special privileges.<br>
	 * * @param thread POSIX thread ID.<br>
	 * @param priority requested thread priority.<br>
	 * * @returns 0, if successful; EPERM, if the calling process lacks<br>
	 * required realtime privileges; otherwise some other error number.<br>
	 * Original signature : <code>int jack_acquire_real_time_scheduling(jack_native_thread_t, int)</code><br>
	 * <i>native declaration : jack/thread.h:70</i>
	 */
	@Mangling({"_Z33jack_acquire_real_time_scheduling20jack_native_thread_ti", "?jack_acquire_real_time_scheduling@@YAH20jack_native_thread_tH@Z"}) 
	int jack_acquire_real_time_scheduling(JackLibrary.jack_native_thread_t thread, int priority);
	/**
	 * Create a thread for JACK or one of its clients.  The thread is<br>
	 * created executing @a start_routine with @a arg as its sole<br>
	 * argument.<br>
	 * * @param client the JACK client for whom the thread is being created. May be<br>
	 * NULL if the client is being created within the JACK server.<br>
	 * @param thread place to return POSIX thread ID.<br>
	 * @param priority thread priority, if realtime.<br>
	 * @param realtime true for the thread to use realtime scheduling.  On<br>
	 * some systems that may require special privileges.<br>
	 * @param start_routine function the thread calls when it starts.<br>
	 * @param arg parameter passed to the @a start_routine.<br>
	 * * @returns 0, if successful; otherwise some error number.<br>
	 * Original signature : <code>int jack_client_create_thread(jack_client_t*, jack_native_thread_t*, int, int, jack_client_create_thread_arg1_start_routine_callback, void*)</code><br>
	 * @param realtime boolean<br>
	 * <i>native declaration : jack/thread.h:88</i>
	 */
	@Mangling({"_Z25jack_client_create_threadP12_jack_clientP20jack_native_thread_tiiPFPvPvEPv", "?jack_client_create_thread@@YAHPA12_jack_clientPA20jack_native_thread_tHHPFPAXPAX@EPAX@Z"}) 
	int jack_client_create_thread(Pointer client, Pointer thread, int priority, int realtime, JackLibrary.jack_client_create_thread_arg1_start_routine_callback arg1, Pointer arg);
	/**
	 * Drop realtime scheduling for a thread.<br>
	 * * @param thread POSIX thread ID.<br>
	 * * @returns 0, if successful; otherwise an error number.<br>
	 * Original signature : <code>int jack_drop_real_time_scheduling(jack_native_thread_t)</code><br>
	 * <i>native declaration : jack/thread.h:102</i>
	 */
	@Mangling({"_Z30jack_drop_real_time_scheduling20jack_native_thread_t", "?jack_drop_real_time_scheduling@@YAH20jack_native_thread_t@Z"}) 
	int jack_drop_real_time_scheduling(JackLibrary.jack_native_thread_t thread);
	/**
	 * Stop the thread, waiting for the thread handler to terminate.<br>
	 * * @param thread POSIX thread ID.<br>
	 * * @returns 0, if successful; otherwise an error number.<br>
	 * Original signature : <code>int jack_client_stop_thread(jack_client_t*, jack_native_thread_t)</code><br>
	 * <i>native declaration : jack/thread.h:111</i>
	 */
	@Mangling({"_Z23jack_client_stop_threadP12_jack_client20jack_native_thread_t", "?jack_client_stop_thread@@YAHPA12_jack_client20jack_native_thread_t@Z"}) 
	int jack_client_stop_thread(Pointer client, JackLibrary.jack_native_thread_t thread);
	/**
	 * Cancel the thread then waits for the thread handler to terminate.<br>
	 * * @param thread POSIX thread ID.<br>
	 * * @returns 0, if successful; otherwise an error number.<br>
	 * Original signature : <code>int jack_client_kill_thread(jack_client_t*, jack_native_thread_t)</code><br>
	 * <i>native declaration : jack/thread.h:120</i>
	 */
	@Mangling({"_Z23jack_client_kill_threadP12_jack_client20jack_native_thread_t", "?jack_client_kill_thread@@YAHPA12_jack_client20jack_native_thread_t@Z"}) 
	int jack_client_kill_thread(Pointer client, JackLibrary.jack_native_thread_t thread);
	/**
	 * This function can be used in very very specialized cases<br>
	 * where it is necessary that client threads created by JACK<br>
	 * are created by something other than pthread_create(). After<br>
	 * it is used, any threads that JACK needs for the client will<br>
	 * will be created by calling the function passed to this<br>
	 * function.<br>
	 * * No normal application/client should consider calling this.<br>
	 * The specific case for which it was created involves running<br>
	 * win32/x86 plugins under Wine on Linux, where it is necessary<br>
	 * that all threads that might call win32 functions are known<br>
	 * to Wine.<br>
	 * * Set it to NULL to restore thread creation function.<br>
	 * * @param creator a function that creates a new thread<br>
	 * Original signature : <code>void jack_set_thread_creator(jack_thread_creator_t)</code><br>
	 * <i>native declaration : jack/thread.h:147</i>
	 */
	@Mangling({"_Z23jack_set_thread_creatorPFiPmP14pthread_attr_tPFPvPvEPvE", "?jack_set_thread_creator@@YAXPFHPAKPATpthread_attr_t@@PFPAXPAX@EPAX@E@Z"}) 
	void jack_set_thread_creator(JackLibrary.jack_thread_creator_t creator);
	/**
	 * Get an internal client's name.  This is useful when @ref<br>
	 * JackUseExactName was not specified on jack_internal_client_load()<br>
	 * and @ref JackNameNotUnique status was returned.  In that case, the<br>
	 * actual name will differ from the @a client_name requested.<br>
	 * * @param client requesting JACK client's handle.<br>
	 * * @param intclient handle returned from jack_internal_client_load()<br>
	 * or jack_internal_client_handle().<br>
	 * * @return NULL if unsuccessful, otherwise pointer to the internal<br>
	 * client name obtained from the heap via malloc().  The caller should<br>
	 * free() this storage when no longer needed.<br>
	 * Original signature : <code>char* jack_get_internal_client_name(jack_client_t*, jack_intclient_t)</code><br>
	 * <i>native declaration : jack/intclient.h:42</i>
	 */
	@Mangling({"_Z29jack_get_internal_client_nameP12_jack_client8uint64_t", "?jack_get_internal_client_name@@YAPADPA12_jack_client8uint64_t@Z"}) 
	Pointer jack_get_internal_client_name(Pointer client, long intclient);
	/**
	 * Return the @ref jack_intclient_t handle for an internal client<br>
	 * running in the JACK server.<br>
	 * * @param client requesting JACK client's handle.<br>
	 * * @param client_name for the internal client of no more than<br>
	 * jack_client_name_size() characters.  The name scope is local to the<br>
	 * current server.<br>
	 * * @param status (if non-NULL) an address for JACK to return<br>
	 * information from this operation.  This status word is formed by<br>
	 * OR-ing together the relevant @ref JackStatus bits.<br>
	 * * @return Opaque internal client handle if successful.  If 0, the<br>
	 * internal client was not found, and @a *status includes the @ref<br>
	 * JackNoSuchClient and @ref JackFailure bits.<br>
	 * Original signature : <code>jack_intclient_t jack_internal_client_handle(jack_client_t*, const char*, jack_status_t*)</code><br>
	 * <i>native declaration : jack/intclient.h:63</i><br>
	 * @deprecated use the safer methods {@link #jack_internal_client_handle(com.sun.jna.Pointer, java.lang.String, java.nio.IntBuffer)} and {@link #jack_internal_client_handle(com.sun.jna.Pointer, com.sun.jna.Pointer, com.sun.jna.ptr.IntByReference)} instead
	 */
	@Mangling({"_Z27jack_internal_client_handleP12_jack_clientPKcP13jack_status_t", "?jack_internal_client_handle@@YA8uint64_tPA12_jack_clientPADPA13jack_status_t@Z"}) 
	@Deprecated 
	long jack_internal_client_handle(Pointer client, Pointer client_name, IntByReference status);
	/**
	 * Return the @ref jack_intclient_t handle for an internal client<br>
	 * running in the JACK server.<br>
	 * * @param client requesting JACK client's handle.<br>
	 * * @param client_name for the internal client of no more than<br>
	 * jack_client_name_size() characters.  The name scope is local to the<br>
	 * current server.<br>
	 * * @param status (if non-NULL) an address for JACK to return<br>
	 * information from this operation.  This status word is formed by<br>
	 * OR-ing together the relevant @ref JackStatus bits.<br>
	 * * @return Opaque internal client handle if successful.  If 0, the<br>
	 * internal client was not found, and @a *status includes the @ref<br>
	 * JackNoSuchClient and @ref JackFailure bits.<br>
	 * Original signature : <code>jack_intclient_t jack_internal_client_handle(jack_client_t*, const char*, jack_status_t*)</code><br>
	 * <i>native declaration : jack/intclient.h:63</i>
	 */
	@Mangling({"_Z27jack_internal_client_handleP12_jack_clientPKcP13jack_status_t", "?jack_internal_client_handle@@YA8uint64_tPA12_jack_clientPADPA13jack_status_t@Z"}) 
	long jack_internal_client_handle(Pointer client, String client_name, IntBuffer status);
	/**
	 * Load an internal client into the JACK server.<br>
	 * * Internal clients run inside the JACK server process.  They can use<br>
	 * most of the same functions as external clients.  Each internal<br>
	 * client is built as a shared object module, which must declare<br>
	 * jack_initialize() and jack_finish() entry points called at load and<br>
	 * unload times.  See @ref inprocess.c for an example.<br>
	 * * @param client loading JACK client's handle.<br>
	 * * @param client_name of at most jack_client_name_size() characters<br>
	 * for the internal client to load.  The name scope is local to the<br>
	 * current server.<br>
	 * * @param options formed by OR-ing together @ref JackOptions bits.<br>
	 * Only the @ref JackLoadOptions bits are valid.<br>
	 * * @param status (if non-NULL) an address for JACK to return<br>
	 * information from the load operation.  This status word is formed by<br>
	 * OR-ing together the relevant @ref JackStatus bits.<br>
	 * * <b>Optional parameters:</b> depending on corresponding [@a options<br>
	 * bits] additional parameters may follow @a status (in this order).<br>
	 * * @arg [@ref JackLoadName] <em>(char *) load_name</em> is the shared<br>
	 * object file from which to load the new internal client (otherwise<br>
	 * use the @a client_name).<br>
	 * * @arg [@ref JackLoadInit] <em>(char *) load_init</em> an arbitary<br>
	 * string passed to the internal client's jack_initialize() routine<br>
	 * (otherwise NULL), of no more than @ref JACK_LOAD_INIT_LIMIT bytes.<br>
	 * * @return Opaque internal client handle if successful.  If this is 0,<br>
	 * the load operation failed, the internal client was not loaded, and<br>
	 * @a *status includes the @ref JackFailure bit.<br>
	 * Original signature : <code>jack_intclient_t jack_internal_client_load(jack_client_t*, const char*, jack_options_t, jack_status_t*, null)</code><br>
	 * <i>native declaration : jack/intclient.h:104</i><br>
	 * @deprecated use the safer methods {@link #jack_internal_client_load(com.sun.jna.Pointer, java.lang.String, int, java.nio.IntBuffer, java.lang.Object)} and {@link #jack_internal_client_load(com.sun.jna.Pointer, com.sun.jna.Pointer, int, com.sun.jna.ptr.IntByReference, java.lang.Object)} instead<br>
	 * @param options @see jack_options_t
	 */
	@Mangling({"_Z25jack_internal_client_loadP12_jack_clientPKc14jack_options_tP13jack_status_tv", "?jack_internal_client_load@@YA8uint64_tPA12_jack_clientPAD14jack_options_tPA13jack_status_tX@Z"}) 
	@Deprecated 
	long jack_internal_client_load(Pointer client, Pointer client_name, int options, IntByReference status, Object... varargs);
	/**
	 * Load an internal client into the JACK server.<br>
	 * * Internal clients run inside the JACK server process.  They can use<br>
	 * most of the same functions as external clients.  Each internal<br>
	 * client is built as a shared object module, which must declare<br>
	 * jack_initialize() and jack_finish() entry points called at load and<br>
	 * unload times.  See @ref inprocess.c for an example.<br>
	 * * @param client loading JACK client's handle.<br>
	 * * @param client_name of at most jack_client_name_size() characters<br>
	 * for the internal client to load.  The name scope is local to the<br>
	 * current server.<br>
	 * * @param options formed by OR-ing together @ref JackOptions bits.<br>
	 * Only the @ref JackLoadOptions bits are valid.<br>
	 * * @param status (if non-NULL) an address for JACK to return<br>
	 * information from the load operation.  This status word is formed by<br>
	 * OR-ing together the relevant @ref JackStatus bits.<br>
	 * * <b>Optional parameters:</b> depending on corresponding [@a options<br>
	 * bits] additional parameters may follow @a status (in this order).<br>
	 * * @arg [@ref JackLoadName] <em>(char *) load_name</em> is the shared<br>
	 * object file from which to load the new internal client (otherwise<br>
	 * use the @a client_name).<br>
	 * * @arg [@ref JackLoadInit] <em>(char *) load_init</em> an arbitary<br>
	 * string passed to the internal client's jack_initialize() routine<br>
	 * (otherwise NULL), of no more than @ref JACK_LOAD_INIT_LIMIT bytes.<br>
	 * * @return Opaque internal client handle if successful.  If this is 0,<br>
	 * the load operation failed, the internal client was not loaded, and<br>
	 * @a *status includes the @ref JackFailure bit.<br>
	 * Original signature : <code>jack_intclient_t jack_internal_client_load(jack_client_t*, const char*, jack_options_t, jack_status_t*, null)</code><br>
	 * <i>native declaration : jack/intclient.h:104</i><br>
	 * @param options @see jack_options_t
	 */
	@Mangling({"_Z25jack_internal_client_loadP12_jack_clientPKc14jack_options_tP13jack_status_tv", "?jack_internal_client_load@@YA8uint64_tPA12_jack_clientPAD14jack_options_tPA13jack_status_tX@Z"}) 
	long jack_internal_client_load(Pointer client, String client_name, int options, IntBuffer status, Object... varargs);
	/**
	 * Unload an internal client from a JACK server.  This calls the<br>
	 * intclient's jack_finish() entry point then removes it.  See @ref<br>
	 * inprocess.c for an example.<br>
	 * * @param client unloading JACK client's handle.<br>
	 * * @param intclient handle returned from jack_internal_client_load() or<br>
	 * jack_internal_client_handle().<br>
	 * * @return 0 if successful, otherwise @ref JackStatus bits.<br>
	 * Original signature : <code>jack_status_t jack_internal_client_unload(jack_client_t*, jack_intclient_t)</code><br>
	 * <i>native declaration : jack/intclient.h:120</i>
	 */
	@Mangling({"_Z27jack_internal_client_unloadP12_jack_client8uint64_t", "?jack_internal_client_unload@@YA13jack_status_tPA12_jack_client8uint64_t@Z"}) 
	/**
	 * @see jack_status_t
	 */int jack_internal_client_unload(Pointer client, long intclient);
	/**
	 * Called by the timebase master to release itself from that<br>
	 * responsibility.<br>
	 * * If the timebase master releases the timebase or leaves the JACK<br>
	 * graph for any reason, the JACK engine takes over at the start of<br>
	 * the next process cycle.  The transport state does not change.  If<br>
	 * rolling, it continues to play, with frame numbers as the only<br>
	 * available position information.<br>
	 * * @see jack_set_timebase_callback<br>
	 * * @param client the JACK client structure.<br>
	 * * @return 0 on success, otherwise a non-zero error code.<br>
	 * Original signature : <code>int jack_release_timebase(jack_client_t*)</code><br>
	 * <i>native declaration : jack/transport.h:49</i>
	 */
	@Mangling({"_Z21jack_release_timebaseP12_jack_client", "?jack_release_timebase@@YAHPA12_jack_client@Z"}) 
	int jack_release_timebase(Pointer client);
	/**
	 * Register (or unregister) as a slow-sync client, one that cannot<br>
	 * respond immediately to transport position changes.<br>
	 * * The @a sync_callback will be invoked at the first available<br>
	 * opportunity after its registration is complete.  If the client is<br>
	 * currently active this will be the following process cycle,<br>
	 * otherwise it will be the first cycle after calling jack_activate().<br>
	 * After that, it runs according to the ::JackSyncCallback rules.<br>
	 * Clients that don't set a @a sync_callback are assumed to be ready<br>
	 * immediately any time the transport wants to start.<br>
	 * * @param client the JACK client structure.<br>
	 * @param sync_callback is a realtime function that returns TRUE when<br>
	 * the client is ready.  Setting @a sync_callback to NULL declares that<br>
	 * this client no longer requires slow-sync processing.<br>
	 * @param arg an argument for the @a sync_callback function.<br>
	 * * @return 0 on success, otherwise a non-zero error code.<br>
	 * Original signature : <code>int jack_set_sync_callback(jack_client_t*, JackSyncCallback, void*)</code><br>
	 * <i>native declaration : jack/transport.h:71</i>
	 */
	@Mangling({"_Z22jack_set_sync_callbackP12_jack_clientPFiiP15jack_position_tPvEPv", "?jack_set_sync_callback@@YAHPA12_jack_clientPFHHPAUjack_position_t@@PAX@EPAX@Z"}) 
	int jack_set_sync_callback(Pointer client, JackLibrary.JackSyncCallback sync_callback, Pointer arg);
	/**
	 * Set the timeout value for slow-sync clients.<br>
	 * * This timeout prevents unresponsive slow-sync clients from<br>
	 * completely halting the transport mechanism.  The default is two<br>
	 * seconds.  When the timeout expires, the transport starts rolling,<br>
	 * even if some slow-sync clients are still unready.  The @a<br>
	 * sync_callbacks of these clients continue being invoked, giving them<br>
	 * a chance to catch up.<br>
	 * * @see jack_set_sync_callback<br>
	 * * @param client the JACK client structure.<br>
	 * @param timeout is delay (in microseconds) before the timeout expires.<br>
	 * * @return 0 on success, otherwise a non-zero error code.<br>
	 * Original signature : <code>int jack_set_sync_timeout(jack_client_t*, uint64_t)</code><br>
	 * <i>native declaration : jack/transport.h:92</i>
	 */
	@Mangling({"_Z21jack_set_sync_timeoutP12_jack_client8uint64_t", "?jack_set_sync_timeout@@YAHPA12_jack_client8uint64_t@Z"}) 
	int jack_set_sync_timeout(Pointer client, long timeout);
	/**
	 * Register as timebase master for the JACK subsystem.<br>
	 * * The timebase master registers a callback that updates extended<br>
	 * position information such as beats or timecode whenever necessary.<br>
	 * Without this extended information, there is no need for this<br>
	 * function.<br>
	 * * There is never more than one master at a time.  When a new client<br>
	 * takes over, the former @a timebase_callback is no longer called.<br>
	 * Taking over the timebase may be done conditionally, so it fails if<br>
	 * there was a master already.<br>
	 * * @param client the JACK client structure.<br>
	 * @param conditional non-zero for a conditional request.<br>
	 * @param timebase_callback is a realtime function that returns<br>
	 * position information.<br>
	 * @param arg an argument for the @a timebase_callback function.<br>
	 * * @return<br>
	 *   - 0 on success;<br>
	 *   - EBUSY if a conditional request fails because there was already a<br>
	 *   timebase master;<br>
	 *   - other non-zero error code.<br>
	 * Original signature : <code>int jack_set_timebase_callback(jack_client_t*, int, JackTimebaseCallback, void*)</code><br>
	 * <i>native declaration : jack/transport.h:120</i>
	 */
	@Mangling({"_Z26jack_set_timebase_callbackP12_jack_clientiPFvi8uint32_tP15jack_position_tiPvEPv", "?jack_set_timebase_callback@@YAHPA12_jack_clientHPFXH8uint32_tPAUjack_position_t@@HPAX@EPAX@Z"}) 
	int jack_set_timebase_callback(Pointer client, int conditional, JackLibrary.JackTimebaseCallback timebase_callback, Pointer arg);
	/**
	 * Reposition the transport to a new frame number.<br>
	 * * May be called at any time by any client.  The new position takes<br>
	 * effect in two process cycles.  If there are slow-sync clients and<br>
	 * the transport is already rolling, it will enter the<br>
	 * ::JackTransportStarting state and begin invoking their @a<br>
	 * sync_callbacks until ready.  This function is realtime-safe.<br>
	 * * @see jack_transport_reposition, jack_set_sync_callback<br>
	 * <br>
	 * @param client the JACK client structure.<br>
	 * @param frame frame number of new transport position.<br>
	 * * @return 0 if valid request, non-zero otherwise.<br>
	 * Original signature : <code>int jack_transport_locate(jack_client_t*, uint32_t)</code><br>
	 * <i>native declaration : jack/transport.h:141</i>
	 */
	@Mangling({"_Z21jack_transport_locateP12_jack_client8uint32_t", "?jack_transport_locate@@YAHPA12_jack_client8uint32_t@Z"}) 
	int jack_transport_locate(Pointer client, int frame);
	/**
	 * Query the current transport state and position.<br>
	 * * This function is realtime-safe, and can be called from any thread.<br>
	 * If called from the process thread, @a pos corresponds to the first<br>
	 * frame of the current cycle and the state returned is valid for the<br>
	 * entire cycle.<br>
	 * * @param client the JACK client structure.<br>
	 * @param pos pointer to structure for returning current transport<br>
	 * position; @a pos->valid will show which fields contain valid data.<br>
	 * If @a pos is NULL, do not return position information.<br>
	 * * @return Current transport state.<br>
	 * Original signature : <code>jack_transport_state_t jack_transport_query(const jack_client_t*, jack_position_t*)</code><br>
	 * <i>native declaration : jack/transport.h:159</i>
	 */
	@Mangling({"_Z20jack_transport_queryPK12_jack_clientP15jack_position_t", "?jack_transport_query@@YAHPA12_jack_clientPAUjack_position_t@@@Z"}) 
	int jack_transport_query(Pointer client, jack_position_t pos);
	/**
	 * Return an estimate of the current transport frame,<br>
	 * including any time elapsed since the last transport<br>
	 * positional update.<br>
	 * * @param client the JACK client structure<br>
	 * Original signature : <code>uint32_t jack_get_current_transport_frame(const jack_client_t*)</code><br>
	 * <i>native declaration : jack/transport.h:169</i>
	 */
	@Mangling({"_Z32jack_get_current_transport_framePK12_jack_client", "?jack_get_current_transport_frame@@YA8uint32_tPA12_jack_client@Z"}) 
	int jack_get_current_transport_frame(Pointer client);
	/**
	 * Request a new transport position.<br>
	 * * May be called at any time by any client.  The new position takes<br>
	 * effect in two process cycles.  If there are slow-sync clients and<br>
	 * the transport is already rolling, it will enter the<br>
	 * ::JackTransportStarting state and begin invoking their @a<br>
	 * sync_callbacks until ready.  This function is realtime-safe.<br>
	 * * @see jack_transport_locate, jack_set_sync_callback<br>
	 * <br>
	 * @param client the JACK client structure.<br>
	 * @param pos requested new transport position.<br>
	 * * @return 0 if valid request, EINVAL if position structure rejected.<br>
	 * Original signature : <code>int jack_transport_reposition(jack_client_t*, jack_position_t*)</code><br>
	 * <i>native declaration : jack/transport.h:187</i>
	 */
	@Mangling({"_Z25jack_transport_repositionP12_jack_clientP15jack_position_t", "?jack_transport_reposition@@YAHPA12_jack_clientPAUjack_position_t@@@Z"}) 
	int jack_transport_reposition(Pointer client, jack_position_t pos);
	/**
	 * Start the JACK transport rolling.<br>
	 * * Any client can make this request at any time.  It takes effect no<br>
	 * sooner than the next process cycle, perhaps later if there are<br>
	 * slow-sync clients.  This function is realtime-safe.<br>
	 * * @see jack_set_sync_callback<br>
	 * * @param client the JACK client structure.<br>
	 * Original signature : <code>void jack_transport_start(jack_client_t*)</code><br>
	 * <i>native declaration : jack/transport.h:201</i>
	 */
	@Mangling({"_Z20jack_transport_startP12_jack_client", "?jack_transport_start@@YAXPA12_jack_client@Z"}) 
	void jack_transport_start(Pointer client);
	/**
	 * Stop the JACK transport.<br>
	 * * Any client can make this request at any time.  It takes effect on<br>
	 * the next process cycle.  This function is realtime-safe.<br>
	 * * @param client the JACK client structure.<br>
	 * Original signature : <code>void jack_transport_stop(jack_client_t*)</code><br>
	 * <i>native declaration : jack/transport.h:211</i>
	 */
	@Mangling({"_Z19jack_transport_stopP12_jack_client", "?jack_transport_stop@@YAXPA12_jack_client@Z"}) 
	void jack_transport_stop(Pointer client);
	/**
	 * Gets the current transport info structure (deprecated).<br>
	 * * @param client the JACK client structure.<br>
	 * @param tinfo current transport info structure.  The "valid" field<br>
	 * describes which fields contain valid data.<br>
	 * * @deprecated This is for compatibility with the earlier transport<br>
	 * interface.  Use jack_transport_query(), instead.<br>
	 * * @pre Must be called from the process thread.<br>
	 * Original signature : <code>void jack_get_transport_info(jack_client_t*, jack_transport_info_t*)</code><br>
	 * <i>native declaration : jack/transport.h:225</i>
	 */
	@Mangling({"_Z23jack_get_transport_infoP12_jack_clientP21jack_transport_info_t", "?jack_get_transport_info@@YAXPA12_jack_clientPAUjack_transport_info_t@@@Z"}) 
	void jack_get_transport_info(Pointer client, jack_transport_info_t tinfo);
	/**
	 * Set the transport info structure (deprecated).<br>
	 * * @deprecated This function still exists for compatibility with the<br>
	 * earlier transport interface, but it does nothing.  Instead, define<br>
	 * a ::JackTimebaseCallback.<br>
	 * Original signature : <code>void jack_set_transport_info(jack_client_t*, jack_transport_info_t*)</code><br>
	 * <i>native declaration : jack/transport.h:235</i>
	 */
	@Mangling({"_Z23jack_set_transport_infoP12_jack_clientP21jack_transport_info_t", "?jack_set_transport_info@@YAXPA12_jack_clientPAUjack_transport_info_t@@@Z"}) 
	void jack_set_transport_info(Pointer client, jack_transport_info_t tinfo);
	/**
	 * @return the maximum delay reported by the backend since<br>
	 * startup or reset.  When compared to the period size in usecs, this<br>
	 * can be used to estimate the ideal period size for a given setup.<br>
	 * Original signature : <code>float jack_get_max_delayed_usecs(jack_client_t*)</code><br>
	 * <i>native declaration : jack/statistics.h:33</i>
	 */
	@Mangling({"_Z26jack_get_max_delayed_usecsP12_jack_client", "?jack_get_max_delayed_usecs@@YAMPA12_jack_client@Z"}) 
	float jack_get_max_delayed_usecs(Pointer client);
	/**
	 * @return the delay in microseconds due to the most recent XRUN<br>
	 * occurrence.  This probably only makes sense when called from a @ref<br>
	 * JackXRunCallback defined using jack_set_xrun_callback().<br>
	 * Original signature : <code>float jack_get_xrun_delayed_usecs(jack_client_t*)</code><br>
	 * <i>native declaration : jack/statistics.h:40</i>
	 */
	@Mangling({"_Z27jack_get_xrun_delayed_usecsP12_jack_client", "?jack_get_xrun_delayed_usecs@@YAMPA12_jack_client@Z"}) 
	float jack_get_xrun_delayed_usecs(Pointer client);
	/**
	 * Reset the maximum delay counter.  This would be useful<br>
	 * to estimate the effect that a change to the configuration of a running<br>
	 * system (e.g. toggling kernel preemption) has on the delay<br>
	 * experienced by JACK, without having to restart the JACK engine.<br>
	 * Original signature : <code>void jack_reset_max_delayed_usecs(jack_client_t*)</code><br>
	 * <i>native declaration : jack/statistics.h:48</i>
	 */
	@Mangling({"_Z28jack_reset_max_delayed_usecsP12_jack_client", "?jack_reset_max_delayed_usecs@@YAXPA12_jack_client@Z"}) 
	void jack_reset_max_delayed_usecs(Pointer client);
	/**
	 * Allocates a ringbuffer data structure of a specified size. The<br>
	 * caller must arrange for a call to jack_ringbuffer_free() to release<br>
	 * the memory associated with the ringbuffer.<br>
	 * * @param sz the ringbuffer size in bytes.<br>
	 * * @return a pointer to a new jack_ringbuffer_t, if successful; NULL<br>
	 * otherwise.<br>
	 * Original signature : <code>jack_ringbuffer_t* jack_ringbuffer_create(size_t)</code><br>
	 * <i>native declaration : jack/ringbuffer.h:68</i>
	 */
	@Mangling({"_Z22jack_ringbuffer_create6size_t", "?jack_ringbuffer_create@@YAPAUjack_ringbuffer_t@@6size_t@Z"}) 
	jack_ringbuffer_t jack_ringbuffer_create(NativeSize sz);
	/**
	 * Frees the ringbuffer data structure allocated by an earlier call to<br>
	 * jack_ringbuffer_create().<br>
	 * * @param rb a pointer to the ringbuffer structure.<br>
	 * Original signature : <code>void jack_ringbuffer_free(jack_ringbuffer_t*)</code><br>
	 * <i>native declaration : jack/ringbuffer.h:76</i>
	 */
	@Mangling({"_Z20jack_ringbuffer_freeP17jack_ringbuffer_t", "?jack_ringbuffer_free@@YAXPAUjack_ringbuffer_t@@@Z"}) 
	void jack_ringbuffer_free(jack_ringbuffer_t rb);
	/**
	 * Fill a data structure with a description of the current readable<br>
	 * data held in the ringbuffer.  This description is returned in a two<br>
	 * element array of jack_ringbuffer_data_t.  Two elements are needed<br>
	 * because the data to be read may be split across the end of the<br>
	 * ringbuffer.<br>
	 * * The first element will always contain a valid @a len field, which<br>
	 * may be zero or greater.  If the @a len field is non-zero, then data<br>
	 * can be read in a contiguous fashion using the address given in the<br>
	 * corresponding @a buf field.<br>
	 * * If the second element has a non-zero @a len field, then a second<br>
	 * contiguous stretch of data can be read from the address given in<br>
	 * its corresponding @a buf field.<br>
	 * * @param rb a pointer to the ringbuffer structure.<br>
	 * @param vec a pointer to a 2 element array of jack_ringbuffer_data_t.<br>
	 * Original signature : <code>void jack_ringbuffer_get_read_vector(const jack_ringbuffer_t*, jack_ringbuffer_data_t*)</code><br>
	 * <i>native declaration : jack/ringbuffer.h:98</i>
	 */
	@Mangling({"_Z31jack_ringbuffer_get_read_vectorPK17jack_ringbuffer_tP22jack_ringbuffer_data_t", "?jack_ringbuffer_get_read_vector@@YAXPAUjack_ringbuffer_t@@PAUjack_ringbuffer_data_t@@@Z"}) 
	void jack_ringbuffer_get_read_vector(jack_ringbuffer_t rb, jack_ringbuffer_data_t vec);
	/**
	 * Fill a data structure with a description of the current writable<br>
	 * space in the ringbuffer.  The description is returned in a two<br>
	 * element array of jack_ringbuffer_data_t.  Two elements are needed<br>
	 * because the space available for writing may be split across the end<br>
	 * of the ringbuffer.<br>
	 * * The first element will always contain a valid @a len field, which<br>
	 * may be zero or greater.  If the @a len field is non-zero, then data<br>
	 * can be written in a contiguous fashion using the address given in<br>
	 * the corresponding @a buf field.<br>
	 * * If the second element has a non-zero @a len field, then a second<br>
	 * contiguous stretch of data can be written to the address given in<br>
	 * the corresponding @a buf field.<br>
	 * * @param rb a pointer to the ringbuffer structure.<br>
	 * @param vec a pointer to a 2 element array of jack_ringbuffer_data_t.<br>
	 * Original signature : <code>void jack_ringbuffer_get_write_vector(const jack_ringbuffer_t*, jack_ringbuffer_data_t*)</code><br>
	 * <i>native declaration : jack/ringbuffer.h:120</i>
	 */
	@Mangling({"_Z32jack_ringbuffer_get_write_vectorPK17jack_ringbuffer_tP22jack_ringbuffer_data_t", "?jack_ringbuffer_get_write_vector@@YAXPAUjack_ringbuffer_t@@PAUjack_ringbuffer_data_t@@@Z"}) 
	void jack_ringbuffer_get_write_vector(jack_ringbuffer_t rb, jack_ringbuffer_data_t vec);
	/**
	 * Read data from the ringbuffer.<br>
	 * * @param rb a pointer to the ringbuffer structure.<br>
	 * @param dest a pointer to a buffer where data read from the<br>
	 * ringbuffer will go.<br>
	 * @param cnt the number of bytes to read.<br>
	 * * @return the number of bytes read, which may range from 0 to cnt.<br>
	 * Original signature : <code>size_t jack_ringbuffer_read(jack_ringbuffer_t*, char*, size_t)</code><br>
	 * <i>native declaration : jack/ringbuffer.h:133</i><br>
	 * @deprecated use the safer methods {@link #jack_ringbuffer_read(jack.jack_ringbuffer_t, java.nio.ByteBuffer, com.ochafik.lang.jnaerator.runtime.NativeSize)} and {@link #jack_ringbuffer_read(jack.jack_ringbuffer_t, com.sun.jna.Pointer, com.ochafik.lang.jnaerator.runtime.NativeSize)} instead
	 */
	@Mangling({"_Z20jack_ringbuffer_readP17jack_ringbuffer_tPc6size_t", "?jack_ringbuffer_read@@YA6size_tPAUjack_ringbuffer_t@@PAD6size_t@Z"}) 
	@Deprecated 
	NativeSize jack_ringbuffer_read(jack_ringbuffer_t rb, Pointer dest, NativeSize cnt);
	/**
	 * Read data from the ringbuffer.<br>
	 * * @param rb a pointer to the ringbuffer structure.<br>
	 * @param dest a pointer to a buffer where data read from the<br>
	 * ringbuffer will go.<br>
	 * @param cnt the number of bytes to read.<br>
	 * * @return the number of bytes read, which may range from 0 to cnt.<br>
	 * Original signature : <code>size_t jack_ringbuffer_read(jack_ringbuffer_t*, char*, size_t)</code><br>
	 * <i>native declaration : jack/ringbuffer.h:133</i>
	 */
	@Mangling({"_Z20jack_ringbuffer_readP17jack_ringbuffer_tPc6size_t", "?jack_ringbuffer_read@@YA6size_tPAUjack_ringbuffer_t@@PAD6size_t@Z"}) 
	NativeSize jack_ringbuffer_read(jack_ringbuffer_t rb, ByteBuffer dest, NativeSize cnt);
	/**
	 * Read data from the ringbuffer. Opposed to jack_ringbuffer_read()<br>
	 * this function does not move the read pointer. Thus it's<br>
	 * a convenient way to inspect data in the ringbuffer in a<br>
	 * continous fashion. The price is that the data is copied<br>
	 * into a user provided buffer. For "raw" non-copy inspection<br>
	 * of the data in the ringbuffer use jack_ringbuffer_get_read_vector().<br>
	 * * @param rb a pointer to the ringbuffer structure.<br>
	 * @param dest a pointer to a buffer where data read from the<br>
	 * ringbuffer will go.<br>
	 * @param cnt the number of bytes to read.<br>
	 * * @return the number of bytes read, which may range from 0 to cnt.<br>
	 * Original signature : <code>size_t jack_ringbuffer_peek(jack_ringbuffer_t*, char*, size_t)</code><br>
	 * <i>native declaration : jack/ringbuffer.h:150</i><br>
	 * @deprecated use the safer methods {@link #jack_ringbuffer_peek(jack.jack_ringbuffer_t, java.nio.ByteBuffer, com.ochafik.lang.jnaerator.runtime.NativeSize)} and {@link #jack_ringbuffer_peek(jack.jack_ringbuffer_t, com.sun.jna.Pointer, com.ochafik.lang.jnaerator.runtime.NativeSize)} instead
	 */
	@Mangling({"_Z20jack_ringbuffer_peekP17jack_ringbuffer_tPc6size_t", "?jack_ringbuffer_peek@@YA6size_tPAUjack_ringbuffer_t@@PAD6size_t@Z"}) 
	@Deprecated 
	NativeSize jack_ringbuffer_peek(jack_ringbuffer_t rb, Pointer dest, NativeSize cnt);
	/**
	 * Read data from the ringbuffer. Opposed to jack_ringbuffer_read()<br>
	 * this function does not move the read pointer. Thus it's<br>
	 * a convenient way to inspect data in the ringbuffer in a<br>
	 * continous fashion. The price is that the data is copied<br>
	 * into a user provided buffer. For "raw" non-copy inspection<br>
	 * of the data in the ringbuffer use jack_ringbuffer_get_read_vector().<br>
	 * * @param rb a pointer to the ringbuffer structure.<br>
	 * @param dest a pointer to a buffer where data read from the<br>
	 * ringbuffer will go.<br>
	 * @param cnt the number of bytes to read.<br>
	 * * @return the number of bytes read, which may range from 0 to cnt.<br>
	 * Original signature : <code>size_t jack_ringbuffer_peek(jack_ringbuffer_t*, char*, size_t)</code><br>
	 * <i>native declaration : jack/ringbuffer.h:150</i>
	 */
	@Mangling({"_Z20jack_ringbuffer_peekP17jack_ringbuffer_tPc6size_t", "?jack_ringbuffer_peek@@YA6size_tPAUjack_ringbuffer_t@@PAD6size_t@Z"}) 
	NativeSize jack_ringbuffer_peek(jack_ringbuffer_t rb, ByteBuffer dest, NativeSize cnt);
	/**
	 * Advance the read pointer.<br>
	 * * After data have been read from the ringbuffer using the pointers<br>
	 * returned by jack_ringbuffer_get_read_vector(), use this function to<br>
	 * advance the buffer pointers, making that space available for future<br>
	 * write operations.<br>
	 * * @param rb a pointer to the ringbuffer structure.<br>
	 * @param cnt the number of bytes read.<br>
	 * Original signature : <code>void jack_ringbuffer_read_advance(jack_ringbuffer_t*, size_t)</code><br>
	 * <i>native declaration : jack/ringbuffer.h:163</i>
	 */
	@Mangling({"_Z28jack_ringbuffer_read_advanceP17jack_ringbuffer_t6size_t", "?jack_ringbuffer_read_advance@@YAXPAUjack_ringbuffer_t@@6size_t@Z"}) 
	void jack_ringbuffer_read_advance(jack_ringbuffer_t rb, NativeSize cnt);
	/**
	 * Return the number of bytes available for reading.<br>
	 * * @param rb a pointer to the ringbuffer structure.<br>
	 * * @return the number of bytes available to read.<br>
	 * Original signature : <code>size_t jack_ringbuffer_read_space(const jack_ringbuffer_t*)</code><br>
	 * <i>native declaration : jack/ringbuffer.h:172</i>
	 */
	@Mangling({"_Z26jack_ringbuffer_read_spacePK17jack_ringbuffer_t", "?jack_ringbuffer_read_space@@YA6size_tPAUjack_ringbuffer_t@@@Z"}) 
	NativeSize jack_ringbuffer_read_space(jack_ringbuffer_t rb);
	/**
	 * Lock a ringbuffer data block into memory.<br>
	 * * Uses the mlock() system call.  This is not a realtime operation.<br>
	 * * @param rb a pointer to the ringbuffer structure.<br>
	 * Original signature : <code>int jack_ringbuffer_mlock(jack_ringbuffer_t*)</code><br>
	 * <i>native declaration : jack/ringbuffer.h:181</i>
	 */
	@Mangling({"_Z21jack_ringbuffer_mlockP17jack_ringbuffer_t", "?jack_ringbuffer_mlock@@YAHPAUjack_ringbuffer_t@@@Z"}) 
	int jack_ringbuffer_mlock(jack_ringbuffer_t rb);
	/**
	 * Reset the read and write pointers, making an empty buffer.<br>
	 * * This is not thread safe.<br>
	 * * @param rb a pointer to the ringbuffer structure.<br>
	 * Original signature : <code>void jack_ringbuffer_reset(jack_ringbuffer_t*)</code><br>
	 * <i>native declaration : jack/ringbuffer.h:190</i>
	 */
	@Mangling({"_Z21jack_ringbuffer_resetP17jack_ringbuffer_t", "?jack_ringbuffer_reset@@YAXPAUjack_ringbuffer_t@@@Z"}) 
	void jack_ringbuffer_reset(jack_ringbuffer_t rb);
	/**
	 * Reset the internal "available" size, and read and write pointers, making an empty buffer.<br>
	 * * This is not thread safe.<br>
	 * * @param rb a pointer to the ringbuffer structure.<br>
	 * @param sz the new size, that must be less than allocated size.<br>
	 * Original signature : <code>void jack_ringbuffer_reset_size(jack_ringbuffer_t*, size_t)</code><br>
	 * <i>native declaration : jack/ringbuffer.h:200</i>
	 */
	@Mangling({"_Z26jack_ringbuffer_reset_sizeP17jack_ringbuffer_t6size_t", "?jack_ringbuffer_reset_size@@YAXPAUjack_ringbuffer_t@@6size_t@Z"}) 
	void jack_ringbuffer_reset_size(jack_ringbuffer_t rb, NativeSize sz);
	/**
	 * Write data into the ringbuffer.<br>
	 * * @param rb a pointer to the ringbuffer structure.<br>
	 * @param src a pointer to the data to be written to the ringbuffer.<br>
	 * @param cnt the number of bytes to write.<br>
	 * * @return the number of bytes write, which may range from 0 to cnt<br>
	 * Original signature : <code>size_t jack_ringbuffer_write(jack_ringbuffer_t*, const char*, size_t)</code><br>
	 * <i>native declaration : jack/ringbuffer.h:211</i><br>
	 * @deprecated use the safer methods {@link #jack_ringbuffer_write(jack.jack_ringbuffer_t, java.lang.String, com.ochafik.lang.jnaerator.runtime.NativeSize)} and {@link #jack_ringbuffer_write(jack.jack_ringbuffer_t, com.sun.jna.Pointer, com.ochafik.lang.jnaerator.runtime.NativeSize)} instead
	 */
	@Mangling({"_Z21jack_ringbuffer_writeP17jack_ringbuffer_tPKc6size_t", "?jack_ringbuffer_write@@YA6size_tPAUjack_ringbuffer_t@@PAD6size_t@Z"}) 
	@Deprecated 
	NativeSize jack_ringbuffer_write(jack_ringbuffer_t rb, Pointer src, NativeSize cnt);
	/**
	 * Write data into the ringbuffer.<br>
	 * * @param rb a pointer to the ringbuffer structure.<br>
	 * @param src a pointer to the data to be written to the ringbuffer.<br>
	 * @param cnt the number of bytes to write.<br>
	 * * @return the number of bytes write, which may range from 0 to cnt<br>
	 * Original signature : <code>size_t jack_ringbuffer_write(jack_ringbuffer_t*, const char*, size_t)</code><br>
	 * <i>native declaration : jack/ringbuffer.h:211</i>
	 */
	@Mangling({"_Z21jack_ringbuffer_writeP17jack_ringbuffer_tPKc6size_t", "?jack_ringbuffer_write@@YA6size_tPAUjack_ringbuffer_t@@PAD6size_t@Z"}) 
	NativeSize jack_ringbuffer_write(jack_ringbuffer_t rb, String src, NativeSize cnt);
	/**
	 * Advance the write pointer.<br>
	 * * After data have been written the ringbuffer using the pointers<br>
	 * returned by jack_ringbuffer_get_write_vector(), use this function<br>
	 * to advance the buffer pointer, making the data available for future<br>
	 * read operations.<br>
	 * * @param rb a pointer to the ringbuffer structure.<br>
	 * @param cnt the number of bytes written.<br>
	 * Original signature : <code>void jack_ringbuffer_write_advance(jack_ringbuffer_t*, size_t)</code><br>
	 * <i>native declaration : jack/ringbuffer.h:225</i>
	 */
	@Mangling({"_Z29jack_ringbuffer_write_advanceP17jack_ringbuffer_t6size_t", "?jack_ringbuffer_write_advance@@YAXPAUjack_ringbuffer_t@@6size_t@Z"}) 
	void jack_ringbuffer_write_advance(jack_ringbuffer_t rb, NativeSize cnt);
	/**
	 * Return the number of bytes available for writing.<br>
	 * * @param rb a pointer to the ringbuffer structure.<br>
	 * * @return the amount of free space (in bytes) available for writing.<br>
	 * Original signature : <code>size_t jack_ringbuffer_write_space(const jack_ringbuffer_t*)</code><br>
	 * <i>native declaration : jack/ringbuffer.h:234</i>
	 */
	@Mangling({"_Z27jack_ringbuffer_write_spacePK17jack_ringbuffer_t", "?jack_ringbuffer_write_space@@YA6size_tPAUjack_ringbuffer_t@@@Z"}) 
	NativeSize jack_ringbuffer_write_space(jack_ringbuffer_t rb);
	/**
	 * Call this function to get version of the JACK, in form of several numbers<br>
	 * * @param major_ptr pointer to variable receiving major version of JACK.<br>
	 * * @param minor_ptr pointer to variable receiving minor version of JACK.<br>
	 * * @param major_ptr pointer to variable receiving micro version of JACK.<br>
	 * * @param major_ptr pointer to variable receiving protocol version of JACK.<br>
	 * Original signature : <code>void jack_get_version(int*, int*, int*, int*)</code><br>
	 * <i>native declaration : jack/jack.h:65</i><br>
	 * @deprecated use the safer methods {@link #jack_get_version(java.nio.IntBuffer, java.nio.IntBuffer, java.nio.IntBuffer, java.nio.IntBuffer)} and {@link #jack_get_version(com.sun.jna.ptr.IntByReference, com.sun.jna.ptr.IntByReference, com.sun.jna.ptr.IntByReference, com.sun.jna.ptr.IntByReference)} instead
	 */
	@Mangling({"_Z16jack_get_versionPiPiPiPi", "?jack_get_version@@YAXPAHPAHPAHPAH@Z"}) 
	@Deprecated 
	void jack_get_version(IntByReference major_ptr, IntByReference minor_ptr, IntByReference micro_ptr, IntByReference proto_ptr);
	/**
	 * Call this function to get version of the JACK, in form of several numbers<br>
	 * * @param major_ptr pointer to variable receiving major version of JACK.<br>
	 * * @param minor_ptr pointer to variable receiving minor version of JACK.<br>
	 * * @param major_ptr pointer to variable receiving micro version of JACK.<br>
	 * * @param major_ptr pointer to variable receiving protocol version of JACK.<br>
	 * Original signature : <code>void jack_get_version(int*, int*, int*, int*)</code><br>
	 * <i>native declaration : jack/jack.h:65</i>
	 */
	@Mangling({"_Z16jack_get_versionPiPiPiPi", "?jack_get_version@@YAXPAHPAHPAHPAH@Z"}) 
	void jack_get_version(IntBuffer major_ptr, IntBuffer minor_ptr, IntBuffer micro_ptr, IntBuffer proto_ptr);
	/**
	 * Call this function to get version of the JACK, in form of a string<br>
	 * * @return Human readable string describing JACK version being used.<br>
	 * Original signature : <code>char* jack_get_version_string()</code><br>
	 * <i>native declaration : jack/jack.h:78</i>
	 */
	@Mangling({"_Z23jack_get_version_stringv", "?jack_get_version_string@@YAQBDXZ"}) 
	String jack_get_version_string();
	/**
	 * Open an external client session with a JACK server.  This interface<br>
	 * is more complex but more powerful than jack_client_new().  With it,<br>
	 * clients may choose which of several servers to connect, and control<br>
	 * whether and how to start the server automatically, if it was not<br>
	 * already running.  There is also an option for JACK to generate a<br>
	 * unique client name, when necessary.<br>
	 * * @param client_name of at most jack_client_name_size() characters.<br>
	 * The name scope is local to each server.  Unless forbidden by the<br>
	 * @ref JackUseExactName option, the server will modify this name to<br>
	 * create a unique variant, if needed.<br>
	 * * @param options formed by OR-ing together @ref JackOptions bits.<br>
	 * Only the @ref JackOpenOptions bits are allowed.<br>
	 * * @param status (if non-NULL) an address for JACK to return<br>
	 * information from the open operation.  This status word is formed by<br>
	 * OR-ing together the relevant @ref JackStatus bits.<br>
	 * *<br>
	 * <b>Optional parameters:</b> depending on corresponding [@a options<br>
	 * bits] additional parameters may follow @a status (in this order).<br>
	 * * @arg [@ref JackServerName] <em>(char *) server_name</em> selects<br>
	 * from among several possible concurrent server instances.  Server<br>
	 * names are unique to each user.  If unspecified, use "default"<br>
	 * unless \$JACK_DEFAULT_SERVER is defined in the process environment.<br>
	 * * @return Opaque client handle if successful.  If this is NULL, the<br>
	 * open operation failed, @a *status includes @ref JackFailure and the<br>
	 * caller is not a JACK client.<br>
	 * Original signature : <code>jack_client_t* jack_client_open(const char*, jack_options_t, jack_status_t*, null)</code><br>
	 * <i>native declaration : jack/jack.h:114</i><br>
	 * @deprecated use the safer methods {@link #jack_client_open(java.lang.String, int, java.nio.IntBuffer, java.lang.Object)} and {@link #jack_client_open(com.sun.jna.Pointer, int, com.sun.jna.ptr.IntByReference, java.lang.Object)} instead<br>
	 * @param options @see jack_options_t
	 */
	@Mangling({"_Z16jack_client_openPKc14jack_options_tP13jack_status_tv", "?jack_client_open@@YAPA12_jack_clientPAD14jack_options_tPA13jack_status_tX@Z"}) 
	@Deprecated 
	Pointer jack_client_open(Pointer client_name, int options, IntByReference status, Object... varargs);
	/**
	 * Open an external client session with a JACK server.  This interface<br>
	 * is more complex but more powerful than jack_client_new().  With it,<br>
	 * clients may choose which of several servers to connect, and control<br>
	 * whether and how to start the server automatically, if it was not<br>
	 * already running.  There is also an option for JACK to generate a<br>
	 * unique client name, when necessary.<br>
	 * * @param client_name of at most jack_client_name_size() characters.<br>
	 * The name scope is local to each server.  Unless forbidden by the<br>
	 * @ref JackUseExactName option, the server will modify this name to<br>
	 * create a unique variant, if needed.<br>
	 * * @param options formed by OR-ing together @ref JackOptions bits.<br>
	 * Only the @ref JackOpenOptions bits are allowed.<br>
	 * * @param status (if non-NULL) an address for JACK to return<br>
	 * information from the open operation.  This status word is formed by<br>
	 * OR-ing together the relevant @ref JackStatus bits.<br>
	 * *<br>
	 * <b>Optional parameters:</b> depending on corresponding [@a options<br>
	 * bits] additional parameters may follow @a status (in this order).<br>
	 * * @arg [@ref JackServerName] <em>(char *) server_name</em> selects<br>
	 * from among several possible concurrent server instances.  Server<br>
	 * names are unique to each user.  If unspecified, use "default"<br>
	 * unless \$JACK_DEFAULT_SERVER is defined in the process environment.<br>
	 * * @return Opaque client handle if successful.  If this is NULL, the<br>
	 * open operation failed, @a *status includes @ref JackFailure and the<br>
	 * caller is not a JACK client.<br>
	 * Original signature : <code>jack_client_t* jack_client_open(const char*, jack_options_t, jack_status_t*, null)</code><br>
	 * <i>native declaration : jack/jack.h:114</i><br>
	 * @param options @see jack_options_t
	 */
	@Mangling({"_Z16jack_client_openPKc14jack_options_tP13jack_status_tv", "?jack_client_open@@YAPA12_jack_clientPAD14jack_options_tPA13jack_status_tX@Z"}) 
	Pointer jack_client_open(String client_name, int options, IntBuffer status, Object... varargs);
	/**
	 * \bold THIS FUNCTION IS DEPRECATED AND SHOULD NOT BE USED IN<br>
	 *  NEW JACK CLIENTS<br>
	 * * @deprecated Please use jack_client_open().<br>
	 * Original signature : <code>jack_client_t* jack_client_new(const char*)</code><br>
	 * <i>native declaration : jack/jack.h:124</i><br>
	 * @deprecated use the safer methods {@link #jack_client_new(java.lang.String)} and {@link #jack_client_new(com.sun.jna.Pointer)} instead
	 */
	@Mangling({"_Z15jack_client_newPKc", "?jack_client_new@@YAPA12_jack_clientPAD@Z"}) 
	@Deprecated 
	Pointer jack_client_new(Pointer client_name);
	/**
	 * \bold THIS FUNCTION IS DEPRECATED AND SHOULD NOT BE USED IN<br>
	 *  NEW JACK CLIENTS<br>
	 * * @deprecated Please use jack_client_open().<br>
	 * Original signature : <code>jack_client_t* jack_client_new(const char*)</code><br>
	 * <i>native declaration : jack/jack.h:124</i>
	 */
	@Mangling({"_Z15jack_client_newPKc", "?jack_client_new@@YAPA12_jack_clientPAD@Z"}) 
	Pointer jack_client_new(String client_name);
	/**
	 * Disconnects an external client from a JACK server.<br>
	 * * @return 0 on success, otherwise a non-zero error code<br>
	 * Original signature : <code>int jack_client_close(jack_client_t*)</code><br>
	 * <i>native declaration : jack/jack.h:131</i>
	 */
	@Mangling({"_Z17jack_client_closeP12_jack_client", "?jack_client_close@@YAHPA12_jack_client@Z"}) 
	int jack_client_close(Pointer client);
	/**
	 * @return the maximum number of characters in a JACK client name<br>
	 * including the final NULL character.  This value is a constant.<br>
	 * Original signature : <code>int jack_client_name_size()</code><br>
	 * <i>native declaration : jack/jack.h:137</i>
	 */
	@Mangling({"_Z21jack_client_name_sizev", "?jack_client_name_size@@YAHXZ"}) 
	int jack_client_name_size();
	/**
	 * @return pointer to actual client name.  This is useful when @ref<br>
	 * JackUseExactName is not specified on open and @ref<br>
	 * JackNameNotUnique status was returned.  In that case, the actual<br>
	 * name will differ from the @a client_name requested.<br>
	 * Original signature : <code>char* jack_get_client_name(jack_client_t*)</code><br>
	 * <i>native declaration : jack/jack.h:145</i>
	 */
	@Mangling({"_Z20jack_get_client_nameP12_jack_client", "?jack_get_client_name@@YAPADPA12_jack_client@Z"}) 
	Pointer jack_get_client_name(Pointer client);
	/**
	 * Load an internal client into the Jack server.<br>
	 * * Internal clients run inside the JACK server process.  They can use<br>
	 * most of the same functions as external clients.  Each internal<br>
	 * client must declare jack_initialize() and jack_finish() entry<br>
	 * points, called at load and unload times.  See inprocess.c for an<br>
	 * example of how to write an internal client.<br>
	 * * @deprecated Please use jack_internal_client_load().<br>
	 * * @param client_name of at most jack_client_name_size() characters.<br>
	 * * @param load_name of a shared object file containing the code for<br>
	 * the new client.<br>
	 * * @param load_init an arbitary string passed to the jack_initialize()<br>
	 * routine of the new client (may be NULL).<br>
	 * * @return 0 if successful.<br>
	 * Original signature : <code>int jack_internal_client_new(const char*, const char*, const char*)</code><br>
	 * <i>native declaration : jack/jack.h:168</i><br>
	 * @deprecated use the safer methods {@link #jack_internal_client_new(java.lang.String, java.lang.String, java.lang.String)} and {@link #jack_internal_client_new(com.sun.jna.Pointer, com.sun.jna.Pointer, com.sun.jna.Pointer)} instead
	 */
	@Mangling({"_Z24jack_internal_client_newPKcPKcPKc", "?jack_internal_client_new@@YAHPADPADPAD@Z"}) 
	@Deprecated 
	int jack_internal_client_new(Pointer client_name, Pointer load_name, Pointer load_init);
	/**
	 * Load an internal client into the Jack server.<br>
	 * * Internal clients run inside the JACK server process.  They can use<br>
	 * most of the same functions as external clients.  Each internal<br>
	 * client must declare jack_initialize() and jack_finish() entry<br>
	 * points, called at load and unload times.  See inprocess.c for an<br>
	 * example of how to write an internal client.<br>
	 * * @deprecated Please use jack_internal_client_load().<br>
	 * * @param client_name of at most jack_client_name_size() characters.<br>
	 * * @param load_name of a shared object file containing the code for<br>
	 * the new client.<br>
	 * * @param load_init an arbitary string passed to the jack_initialize()<br>
	 * routine of the new client (may be NULL).<br>
	 * * @return 0 if successful.<br>
	 * Original signature : <code>int jack_internal_client_new(const char*, const char*, const char*)</code><br>
	 * <i>native declaration : jack/jack.h:168</i>
	 */
	@Mangling({"_Z24jack_internal_client_newPKcPKcPKc", "?jack_internal_client_new@@YAHPADPADPAD@Z"}) 
	int jack_internal_client_new(String client_name, String load_name, String load_init);
	/**
	 * Remove an internal client from a JACK server.<br>
	 * * @deprecated Please use jack_internal_client_load().<br>
	 * Original signature : <code>void jack_internal_client_close(const char*)</code><br>
	 * <i>native declaration : jack/jack.h:177</i><br>
	 * @deprecated use the safer methods {@link #jack_internal_client_close(java.lang.String)} and {@link #jack_internal_client_close(com.sun.jna.Pointer)} instead
	 */
	@Mangling({"_Z26jack_internal_client_closePKc", "?jack_internal_client_close@@YAXPAD@Z"}) 
	@Deprecated 
	void jack_internal_client_close(Pointer client_name);
	/**
	 * Remove an internal client from a JACK server.<br>
	 * * @deprecated Please use jack_internal_client_load().<br>
	 * Original signature : <code>void jack_internal_client_close(const char*)</code><br>
	 * <i>native declaration : jack/jack.h:177</i>
	 */
	@Mangling({"_Z26jack_internal_client_closePKc", "?jack_internal_client_close@@YAXPAD@Z"}) 
	void jack_internal_client_close(String client_name);
	/**
	 * Tell the Jack server that the program is ready to start processing<br>
	 * audio.<br>
	 * * @return 0 on success, otherwise a non-zero error code<br>
	 * Original signature : <code>int jack_activate(jack_client_t*)</code><br>
	 * <i>native declaration : jack/jack.h:185</i>
	 */
	@Mangling({"_Z13jack_activateP12_jack_client", "?jack_activate@@YAHPA12_jack_client@Z"}) 
	int jack_activate(Pointer client);
	/**
	 * Tell the Jack server to remove this @a client from the process<br>
	 * graph.  Also, disconnect all ports belonging to it, since inactive<br>
	 * clients have no port connections.<br>
	 * * @return 0 on success, otherwise a non-zero error code<br>
	 * Original signature : <code>int jack_deactivate(jack_client_t*)</code><br>
	 * <i>native declaration : jack/jack.h:194</i>
	 */
	@Mangling({"_Z15jack_deactivateP12_jack_client", "?jack_deactivate@@YAHPA12_jack_client@Z"}) 
	int jack_deactivate(Pointer client);
	/**
	 * @return pid of client. If not available, 0 will be returned.<br>
	 * Original signature : <code>int jack_get_client_pid(const char*)</code><br>
	 * <i>native declaration : jack/jack.h:199</i><br>
	 * @deprecated use the safer methods {@link #jack_get_client_pid(java.lang.String)} and {@link #jack_get_client_pid(com.sun.jna.Pointer)} instead
	 */
	@Mangling({"_Z19jack_get_client_pidPKc", "?jack_get_client_pid@@YAHPAD@Z"}) 
	@Deprecated 
	int jack_get_client_pid(Pointer name);
	/**
	 * @return pid of client. If not available, 0 will be returned.<br>
	 * Original signature : <code>int jack_get_client_pid(const char*)</code><br>
	 * <i>native declaration : jack/jack.h:199</i>
	 */
	@Mangling({"_Z19jack_get_client_pidPKc", "?jack_get_client_pid@@YAHPAD@Z"}) 
	int jack_get_client_pid(String name);
	/**
	 * @return the pthread ID of the thread running the JACK client side<br>
	 * code.<br>
	 * Original signature : <code>jack_native_thread_t jack_client_thread_id(jack_client_t*)</code><br>
	 * <i>native declaration : jack/jack.h:205</i>
	 */
	@Mangling({"_Z21jack_client_thread_idP12_jack_client", "?jack_client_thread_id@@YA20jack_native_thread_tPA12_jack_client@Z"}) 
	JackLibrary.jack_native_thread_t jack_client_thread_id(Pointer jack_client_tPtr1);
	/**
	 * @param client pointer to JACK client structure.<br>
	 * * Check if the JACK subsystem is running with -R (--realtime).<br>
	 * * @return 1 if JACK is running realtime, 0 otherwise<br>
	 * Original signature : <code>int jack_is_realtime(jack_client_t*)</code><br>
	 * <i>native declaration : jack/jack.h:216</i>
	 */
	@Mangling({"_Z16jack_is_realtimeP12_jack_client", "?jack_is_realtime@@YAHPA12_jack_client@Z"}) 
	int jack_is_realtime(Pointer client);
	/**
	 * \bold THIS FUNCTION IS DEPRECATED AND SHOULD NOT BE USED IN<br>
	 *  NEW JACK CLIENTS.<br>
	 * * @deprecated Please use jack_cycle_wait() and jack_cycle_signal() functions.<br>
	 * Original signature : <code>uint32_t jack_thread_wait(jack_client_t*, int)</code><br>
	 * <i>native declaration : jack/jack.h:229</i>
	 */
	@Mangling({"_Z16jack_thread_waitP12_jack_clienti", "?jack_thread_wait@@YA8uint32_tPA12_jack_clientH@Z"}) 
	int jack_thread_wait(Pointer jack_client_tPtr1, int status);
	/**
	 * Wait until this JACK client should process data.<br>
	 * * @param client - pointer to a JACK client structure<br>
	 * * @return the number of frames of data to process<br>
	 * Original signature : <code>uint32_t jack_cycle_wait(jack_client_t*)</code><br>
	 * <i>native declaration : jack/jack.h:238</i>
	 */
	@Mangling({"_Z15jack_cycle_waitP12_jack_client", "?jack_cycle_wait@@YA8uint32_tPA12_jack_client@Z"}) 
	int jack_cycle_wait(Pointer client);
	/**
	 * Signal next clients in the graph.<br>
	 * * @param client - pointer to a JACK client structure<br>
	 * @param status - if non-zero, calling thread should exit<br>
	 * Original signature : <code>void jack_cycle_signal(jack_client_t*, int)</code><br>
	 * <i>native declaration : jack/jack.h:246</i>
	 */
	@Mangling({"_Z17jack_cycle_signalP12_jack_clienti", "?jack_cycle_signal@@YAXPA12_jack_clientH@Z"}) 
	void jack_cycle_signal(Pointer client, int status);
	/**
	 * Tell the Jack server to call @a thread_callback in the RT thread.<br>
	 * Typical use are in conjunction with @a jack_cycle_wait and @a jack_cycle_signal functions.<br>
	 * The code in the supplied function must be suitable for real-time<br>
	 * execution.  That means that it cannot call functions that might<br>
	 * block for a long time. This includes malloc, free, printf,<br>
	 * pthread_mutex_lock, sleep, wait, poll, select, pthread_join,<br>
	 * pthread_cond_wait, etc, etc. See<br>
	 * http://jackit.sourceforge.net/docs/design/design.html#SECTION00411000000000000000<br>
	 * for more information.<br>
	 * * NOTE: this function cannot be called while the client is activated<br>
	 * (after jack_activate has been called.)<br>
	 * * @return 0 on success, otherwise a non-zero error code.<br>
	 * Original signature : <code>int jack_set_process_thread(jack_client_t*, JackThreadCallback, void*)</code><br>
	 * <i>native declaration : jack/jack.h:264</i>
	 */
	@Mangling({"_Z23jack_set_process_threadP12_jack_clientPFPvPvEPv", "?jack_set_process_thread@@YAHPA12_jack_clientPFPAXPAX@EPAX@Z"}) 
	int jack_set_process_thread(Pointer client, JackLibrary.JackThreadCallback thread_callback, Pointer arg);
	/**
	 * Tell JACK to call @a thread_init_callback once just after<br>
	 * the creation of the thread in which all other callbacks<br>
	 * will be handled.<br>
	 * * The code in the supplied function does not need to be<br>
	 * suitable for real-time execution.<br>
	 * * NOTE: this function cannot be called while the client is activated<br>
	 * (after jack_activate has been called.)<br>
	 * * @return 0 on success, otherwise a non-zero error code, causing JACK<br>
	 * to remove that client from the process() graph.<br>
	 * Original signature : <code>int jack_set_thread_init_callback(jack_client_t*, JackThreadInitCallback, void*)</code><br>
	 * <i>native declaration : jack/jack.h:287</i>
	 */
	@Mangling({"_Z29jack_set_thread_init_callbackP12_jack_clientPFvPvEPv", "?jack_set_thread_init_callback@@YAHPA12_jack_clientPFXPAX@EPAX@Z"}) 
	int jack_set_thread_init_callback(Pointer client, JackLibrary.JackThreadInitCallback thread_init_callback, Pointer arg);
	/**
	 * @param client pointer to JACK client structure.<br>
	 * @param function The jack_shutdown function pointer.<br>
	 * @param arg The arguments for the jack_shutdown function.<br>
	 * * Register a function (and argument) to be called if and when the<br>
	 * JACK server shuts down the client thread.  The function must<br>
	 * be written as if it were an asynchonrous POSIX signal<br>
	 * handler --- use only async-safe functions, and remember that it<br>
	 * is executed from another thread.  A typical function might<br>
	 * set a flag or write to a pipe so that the rest of the<br>
	 * application knows that the JACK client thread has shut<br>
	 * down.<br>
	 * * NOTE: clients do not need to call this.  It exists only<br>
	 * to help more complex clients understand what is going<br>
	 * on.  It should be called before jack_client_activate().<br>
	 * * NOTE: if a client calls this AND jack_on_info_shutdown(), then<br>
	 * the event of a client thread shutdown, the callback<br>
	 * passed to this function will not be called, and the one passed to<br>
	 * jack_on_info_shutdown() will.<br>
	 * Original signature : <code>void jack_on_shutdown(jack_client_t*, JackShutdownCallback, void*)</code><br>
	 * <i>native declaration : jack/jack.h:314</i>
	 */
	@Mangling({"_Z16jack_on_shutdownP12_jack_clientPFvPvEPv", "?jack_on_shutdown@@YAXPA12_jack_clientPFXPAX@EPAX@Z"}) 
	void jack_on_shutdown(Pointer client, JackLibrary.JackShutdownCallback shutdown_callback, Pointer arg);
	/**
	 * @param client pointer to JACK client structure.<br>
	 * @param function The jack_info_shutdown function pointer.<br>
	 * @param arg The arguments for the jack_info_shutdown function.<br>
	 * * Register a function (and argument) to be called if and when the<br>
	 * JACK server shuts down the client thread.  The function must<br>
	 * be written as if it were an asynchonrous POSIX signal<br>
	 * handler --- use only async-safe functions, and remember that it<br>
	 * is executed from another thread.  A typical function might<br>
	 * set a flag or write to a pipe so that the rest of the<br>
	 * application knows that the JACK client thread has shut<br>
	 * down.<br>
	 * * NOTE: clients do not need to call this.  It exists only<br>
	 * to help more complex clients understand what is going<br>
	 * on.  It should be called before jack_client_activate().<br>
	 * * NOTE: if a client calls this AND jack_on_info_shutdown(), then<br>
	 * the event of a client thread shutdown, the callback<br>
	 * passed to this function will not be called, and the one passed to<br>
	 * jack_on_info_shutdown() will.<br>
	 * Original signature : <code>void jack_on_info_shutdown(jack_client_t*, JackInfoShutdownCallback, void*)</code><br>
	 * <i>native declaration : jack/jack.h:340</i>
	 */
	@Mangling({"_Z21jack_on_info_shutdownP12_jack_clientPFv13jack_status_tPKcPvEPv", "?jack_on_info_shutdown@@YAXPA12_jack_clientPFX13jack_status_tPADPAX@EPAX@Z"}) 
	void jack_on_info_shutdown(Pointer client, JackLibrary.JackInfoShutdownCallback shutdown_callback, Pointer arg);
	/**
	 * Tell the Jack server to call @a process_callback whenever there is<br>
	 * work be done, passing @a arg as the second argument.<br>
	 * * The code in the supplied function must be suitable for real-time<br>
	 * execution.  That means that it cannot call functions that might<br>
	 * block for a long time. This includes malloc, free, printf,<br>
	 * pthread_mutex_lock, sleep, wait, poll, select, pthread_join,<br>
	 * pthread_cond_wait, etc, etc. See<br>
	 * http://jackit.sourceforge.net/docs/design/design.html#SECTION00411000000000000000<br>
	 * for more information.<br>
	 * * NOTE: this function cannot be called while the client is activated<br>
	 * (after jack_activate has been called.)<br>
	 * * @return 0 on success, otherwise a non-zero error code.<br>
	 * Original signature : <code>int jack_set_process_callback(jack_client_t*, JackProcessCallback, void*)</code><br>
	 * <i>native declaration : jack/jack.h:360</i>
	 */
	@Mangling({"_Z25jack_set_process_callbackP12_jack_clientPFi8uint32_tPvEPv", "?jack_set_process_callback@@YAHPA12_jack_clientPFH8uint32_tPAX@EPAX@Z"}) 
	int jack_set_process_callback(Pointer client, JackLibrary.JackProcessCallback process_callback, Pointer arg);
	/**
	 * Tell the Jack server to call @a freewheel_callback<br>
	 * whenever we enter or leave "freewheel" mode, passing @a<br>
	 * arg as the second argument. The first argument to the<br>
	 * callback will be non-zero if JACK is entering freewheel<br>
	 * mode, and zero otherwise.<br>
	 * * All "notification events" are received in a seperated non RT thread,<br>
	 * the code in the supplied function does not need to be<br>
	 * suitable for real-time execution.<br>
	 * * NOTE: this function cannot be called while the client is activated<br>
	 * (after jack_activate has been called.)<br>
	 * * @return 0 on success, otherwise a non-zero error code.<br>
	 * Original signature : <code>int jack_set_freewheel_callback(jack_client_t*, JackFreewheelCallback, void*)</code><br>
	 * <i>native declaration : jack/jack.h:380</i>
	 */
	@Mangling({"_Z27jack_set_freewheel_callbackP12_jack_clientPFviPvEPv", "?jack_set_freewheel_callback@@YAHPA12_jack_clientPFXHPAX@EPAX@Z"}) 
	int jack_set_freewheel_callback(Pointer client, JackLibrary.JackFreewheelCallback freewheel_callback, Pointer arg);
	/**
	 * Tell JACK to call @a bufsize_callback whenever the size of the the<br>
	 * buffer that will be passed to the @a process_callback is about to<br>
	 * change.  Clients that depend on knowing the buffer size must supply<br>
	 * a @a bufsize_callback before activating themselves.<br>
	 * * All "notification events" are received in a seperated non RT thread,<br>
	 * the code in the supplied function does not need to be<br>
	 * suitable for real-time execution.<br>
	 * * NOTE: this function cannot be called while the client is activated<br>
	 * (after jack_activate has been called.)<br>
	 * * @param client pointer to JACK client structure.<br>
	 * @param bufsize_callback function to call when the buffer size changes.<br>
	 * @param arg argument for @a bufsize_callback.<br>
	 * * @return 0 on success, otherwise a non-zero error code<br>
	 * Original signature : <code>int jack_set_buffer_size_callback(jack_client_t*, JackBufferSizeCallback, void*)</code><br>
	 * <i>native declaration : jack/jack.h:403</i>
	 */
	@Mangling({"_Z29jack_set_buffer_size_callbackP12_jack_clientPFi8uint32_tPvEPv", "?jack_set_buffer_size_callback@@YAHPA12_jack_clientPFH8uint32_tPAX@EPAX@Z"}) 
	int jack_set_buffer_size_callback(Pointer client, JackLibrary.JackBufferSizeCallback bufsize_callback, Pointer arg);
	/**
	 * Tell the Jack server to call @a srate_callback whenever the system<br>
	 * sample rate changes.<br>
	 * * All "notification events" are received in a seperated non RT thread,<br>
	 * the code in the supplied function does not need to be<br>
	 * suitable for real-time execution.<br>
	 * * NOTE: this function cannot be called while the client is activated<br>
	 * (after jack_activate has been called.)<br>
	 * * @return 0 on success, otherwise a non-zero error code<br>
	 * Original signature : <code>int jack_set_sample_rate_callback(jack_client_t*, JackSampleRateCallback, void*)</code><br>
	 * <i>native declaration : jack/jack.h:420</i>
	 */
	@Mangling({"_Z29jack_set_sample_rate_callbackP12_jack_clientPFi8uint32_tPvEPv", "?jack_set_sample_rate_callback@@YAHPA12_jack_clientPFH8uint32_tPAX@EPAX@Z"}) 
	int jack_set_sample_rate_callback(Pointer client, JackLibrary.JackSampleRateCallback srate_callback, Pointer arg);
	/**
	 * Tell the JACK server to call @a client_registration_callback whenever a<br>
	 * client is registered or unregistered, passing @a arg as a parameter.<br>
	 * * All "notification events" are received in a seperated non RT thread,<br>
	 * the code in the supplied function does not need to be<br>
	 * suitable for real-time execution.<br>
	 * * NOTE: this function cannot be called while the client is activated<br>
	 * (after jack_activate has been called.)<br>
	 * * @return 0 on success, otherwise a non-zero error code<br>
	 * Original signature : <code>int jack_set_client_registration_callback(jack_client_t*, JackClientRegistrationCallback, void*)</code><br>
	 * <i>native declaration : jack/jack.h:437</i>
	 */
	@Mangling({"_Z37jack_set_client_registration_callbackP12_jack_clientPFvPKciPvEPv", "?jack_set_client_registration_callback@@YAHPA12_jack_clientPFXPADHPAX@EPAX@Z"}) 
	int jack_set_client_registration_callback(Pointer jack_client_tPtr1, JackLibrary.JackClientRegistrationCallback registration_callback, Pointer arg);
	/**
	 * Tell the JACK server to call @a registration_callback whenever a<br>
	 * port is registered or unregistered, passing @a arg as a parameter.<br>
	 * * All "notification events" are received in a seperated non RT thread,<br>
	 * the code in the supplied function does not need to be<br>
	 * suitable for real-time execution.<br>
	 * * NOTE: this function cannot be called while the client is activated<br>
	 * (after jack_activate has been called.)<br>
	 * * @return 0 on success, otherwise a non-zero error code<br>
	 * Original signature : <code>int jack_set_port_registration_callback(jack_client_t*, JackPortRegistrationCallback, void*)</code><br>
	 * <i>native declaration : jack/jack.h:454</i>
	 */
	@Mangling({"_Z35jack_set_port_registration_callbackP12_jack_clientPFv8uint32_tiPvEPv", "?jack_set_port_registration_callback@@YAHPA12_jack_clientPFX8uint32_tHPAX@EPAX@Z"}) 
	int jack_set_port_registration_callback(Pointer jack_client_tPtr1, JackLibrary.JackPortRegistrationCallback registration_callback, Pointer arg);
	/**
	 * Tell the JACK server to call @a connect_callback whenever a<br>
	 * port is connected or disconnected, passing @a arg as a parameter.<br>
	 * * All "notification events" are received in a seperated non RT thread,<br>
	 * the code in the supplied function does not need to be<br>
	 * suitable for real-time execution.<br>
	 * * NOTE: this function cannot be called while the client is activated<br>
	 * (after jack_activate has been called.)<br>
	 * * @return 0 on success, otherwise a non-zero error code<br>
	 * Original signature : <code>int jack_set_port_connect_callback(jack_client_t*, JackPortConnectCallback, void*)</code><br>
	 * <i>native declaration : jack/jack.h:471</i>
	 */
	@Mangling({"_Z30jack_set_port_connect_callbackP12_jack_clientPFv8uint32_t8uint32_tiPvEPv", "?jack_set_port_connect_callback@@YAHPA12_jack_clientPFX8uint32_t8uint32_tHPAX@EPAX@Z"}) 
	int jack_set_port_connect_callback(Pointer jack_client_tPtr1, JackLibrary.JackPortConnectCallback connect_callback, Pointer arg);
	/**
	 * Tell the JACK server to call @a rename_callback whenever a<br>
	 * port is renamed, passing @a arg as a parameter.<br>
	 * * All "notification events" are received in a seperated non RT thread,<br>
	 * the code in the supplied function does not need to be<br>
	 * suitable for real-time execution.<br>
	 * * NOTE: this function cannot be called while the client is activated<br>
	 * (after jack_activate has been called.)<br>
	 * * @return 0 on success, otherwise a non-zero error code<br>
	 * Original signature : <code>int jack_set_port_rename_callback(jack_client_t*, JackPortRenameCallback, void*)</code><br>
	 * <i>native declaration : jack/jack.h:488</i>
	 */
	@Mangling({"_Z29jack_set_port_rename_callbackP12_jack_clientPFi8uint32_tPKcPKcPvEPv", "?jack_set_port_rename_callback@@YAHPA12_jack_clientPFH8uint32_tPADPADPAX@EPAX@Z"}) 
	int jack_set_port_rename_callback(Pointer jack_client_tPtr1, JackLibrary.JackPortRenameCallback rename_callback, Pointer arg);
	/**
	 * Tell the JACK server to call @a graph_callback whenever the<br>
	 * processing graph is reordered, passing @a arg as a parameter.<br>
	 * * All "notification events" are received in a seperated non RT thread,<br>
	 * the code in the supplied function does not need to be<br>
	 * suitable for real-time execution.<br>
	 * * NOTE: this function cannot be called while the client is activated<br>
	 * (after jack_activate has been called.)<br>
	 * * @return 0 on success, otherwise a non-zero error code<br>
	 * Original signature : <code>int jack_set_graph_order_callback(jack_client_t*, JackGraphOrderCallback, void*)</code><br>
	 * <i>native declaration : jack/jack.h:505</i>
	 */
	@Mangling({"_Z29jack_set_graph_order_callbackP12_jack_clientPFiPvEPv", "?jack_set_graph_order_callback@@YAHPA12_jack_clientPFHPAX@EPAX@Z"}) 
	int jack_set_graph_order_callback(Pointer jack_client_tPtr1, JackLibrary.JackGraphOrderCallback graph_callback, Pointer voidPtr1);
	/**
	 * Tell the JACK server to call @a xrun_callback whenever there is a<br>
	 * xrun, passing @a arg as a parameter.<br>
	 * * All "notification events" are received in a seperated non RT thread,<br>
	 * the code in the supplied function does not need to be<br>
	 * suitable for real-time execution.<br>
	 * * NOTE: this function cannot be called while the client is activated<br>
	 * (after jack_activate has been called.)<br>
	 * * @return 0 on success, otherwise a non-zero error code<br>
	 * Original signature : <code>int jack_set_xrun_callback(jack_client_t*, JackXRunCallback, void*)</code><br>
	 * <i>native declaration : jack/jack.h:522</i>
	 */
	@Mangling({"_Z22jack_set_xrun_callbackP12_jack_clientPFiPvEPv", "?jack_set_xrun_callback@@YAHPA12_jack_clientPFHPAX@EPAX@Z"}) 
	int jack_set_xrun_callback(Pointer jack_client_tPtr1, JackLibrary.JackXRunCallback xrun_callback, Pointer arg);
	/**
	 * Tell the Jack server to call @a latency_callback whenever it<br>
	 * is necessary to recompute the latencies for some or all<br>
	 * Jack ports.<br>
	 * * @a latency_callback will be called twice each time it is<br>
	 * needed, once being passed JackCaptureLatency and once<br>
	 * JackPlaybackLatency. See @ref LatencyFunctions for<br>
	 * the definition of each type of latency and related functions.<br>
	 * * <b>IMPORTANT: Most JACK clients do NOT need to register a latency<br>
	 * callback.</b><br>
	 * * Clients that meet any of the following conditions do NOT<br>
	 * need to register a latency callback:<br>
	 * *    - have only input ports<br>
	 *    - have only output ports<br>
	 *    - their output is totally unrelated to their input<br>
	 *    - their output is not delayed relative to their input<br>
	 *        (i.e. data that arrives in a given process()<br>
	 *         callback is processed and output again in the<br>
	 *         same callback)<br>
	 * * Clients NOT registering a latency callback MUST also<br>
	 * satisfy this condition:<br>
	 * *    - have no multiple distinct internal signal pathways<br>
	 * * This means that if your client has more than 1 input and<br>
	 * output port, and considers them always "correlated"<br>
	 * (e.g. as a stereo pair), then there is only 1 (e.g. stereo)<br>
	 * signal pathway through the client. This would be true,<br>
	 * for example, of a stereo FX rack client that has a<br>
	 * left/right input pair and a left/right output pair.<br>
	 * * However, this is somewhat a matter of perspective. The<br>
	 * same FX rack client could be connected so that its<br>
	 * two input ports were connected to entirely separate<br>
	 * sources. Under these conditions, the fact that the client<br>
	 * does not register a latency callback MAY result<br>
	 * in port latency values being incorrect.<br>
	 * * Clients that do not meet any of those conditions SHOULD<br>
	 * register a latency callback.<br>
	 * * See the documentation for  @ref jack_port_set_latency_range()<br>
	 * on how the callback should operate. Remember that the @a mode<br>
	 * argument given to the latency callback will need to be<br>
	 * passed into @ref jack_port_set_latency_range()<br>
	 * * @return 0 on success, otherwise a non-zero error code<br>
	 * Original signature : <code>int jack_set_latency_callback(jack_client_t*, JackLatencyCallback, void*)</code><br>
	 * <i>native declaration : jack/jack.h:580</i>
	 */
	@Mangling({"_Z25jack_set_latency_callbackP12_jack_clientPFv28jack_latency_callback_mode_tPvEPv", "?jack_set_latency_callback@@YAHPA12_jack_clientPFX28jack_latency_callback_mode_tPAX@EPAX@Z"}) 
	int jack_set_latency_callback(Pointer jack_client_tPtr1, JackLibrary.JackLatencyCallback latency_callback, Pointer voidPtr1);
	/**
	 * Start/Stop JACK's "freewheel" mode.<br>
	 * * When in "freewheel" mode, JACK no longer waits for<br>
	 * any external event to begin the start of the next process<br>
	 * cycle.<br>
	 * * As a result, freewheel mode causes "faster than realtime"<br>
	 * execution of a JACK graph. If possessed, real-time<br>
	 * scheduling is dropped when entering freewheel mode, and<br>
	 * if appropriate it is reacquired when stopping.<br>
	 * * IMPORTANT: on systems using capabilities to provide real-time<br>
	 * scheduling (i.e. Linux kernel 2.4), if onoff is zero, this function<br>
	 * must be called from the thread that originally called jack_activate().<br>
	 * This restriction does not apply to other systems (e.g. Linux kernel 2.6<br>
	 * or OS X).<br>
	 * * @param client pointer to JACK client structure<br>
	 * @param onoff  if non-zero, freewheel mode starts. Otherwise<br>
	 *                  freewheel mode ends.<br>
	 * * @return 0 on success, otherwise a non-zero error code.<br>
	 * Original signature : <code>int jack_set_freewheel(jack_client_t*, int)</code><br>
	 * <i>native declaration : jack/jack.h:614</i>
	 */
	@Mangling({"_Z18jack_set_freewheelP12_jack_clienti", "?jack_set_freewheel@@YAHPA12_jack_clientH@Z"}) 
	int jack_set_freewheel(Pointer client, int onoff);
	/**
	 * Change the buffer size passed to the @a process_callback.<br>
	 * * This operation stops the JACK engine process cycle, then calls all<br>
	 * registered @a bufsize_callback functions before restarting the<br>
	 * process cycle.  This will cause a gap in the audio flow, so it<br>
	 * should only be done at appropriate stopping points.<br>
	 * * @see jack_set_buffer_size_callback()<br>
	 * * @param client pointer to JACK client structure.<br>
	 * @param nframes new buffer size.  Must be a power of two.<br>
	 * * @return 0 on success, otherwise a non-zero error code<br>
	 * Original signature : <code>int jack_set_buffer_size(jack_client_t*, uint32_t)</code><br>
	 * <i>native declaration : jack/jack.h:631</i>
	 */
	@Mangling({"_Z20jack_set_buffer_sizeP12_jack_client8uint32_t", "?jack_set_buffer_size@@YAHPA12_jack_client8uint32_t@Z"}) 
	int jack_set_buffer_size(Pointer client, int nframes);
	/**
	 * @return the sample rate of the jack system, as set by the user when<br>
	 * jackd was started.<br>
	 * Original signature : <code>uint32_t jack_get_sample_rate(jack_client_t*)</code><br>
	 * <i>native declaration : jack/jack.h:637</i>
	 */
	@Mangling({"_Z20jack_get_sample_rateP12_jack_client", "?jack_get_sample_rate@@YA8uint32_tPA12_jack_client@Z"}) 
	int jack_get_sample_rate(Pointer jack_client_tPtr1);
	/**
	 * @return the current maximum size that will ever be passed to the @a<br>
	 * process_callback.  It should only be used *before* the client has<br>
	 * been activated.  This size may change, clients that depend on it<br>
	 * must register a @a bufsize_callback so they will be notified if it<br>
	 * does.<br>
	 * * @see jack_set_buffer_size_callback()<br>
	 * Original signature : <code>uint32_t jack_get_buffer_size(jack_client_t*)</code><br>
	 * <i>native declaration : jack/jack.h:648</i>
	 */
	@Mangling({"_Z20jack_get_buffer_sizeP12_jack_client", "?jack_get_buffer_size@@YA8uint32_tPA12_jack_client@Z"}) 
	int jack_get_buffer_size(Pointer jack_client_tPtr1);
	/**
	 * Old-style interface to become the timebase for the entire JACK<br>
	 * subsystem.<br>
	 * * @deprecated This function still exists for compatibility with the<br>
	 * earlier transport interface, but it does nothing.  Instead, see<br>
	 * transport.h and use jack_set_timebase_callback().<br>
	 * * @return ENOSYS, function not implemented.<br>
	 * Original signature : <code>int jack_engine_takeover_timebase(jack_client_t*)</code><br>
	 * <i>native declaration : jack/jack.h:660</i>
	 */
	@Mangling({"_Z29jack_engine_takeover_timebaseP12_jack_client", "?jack_engine_takeover_timebase@@YAHPA12_jack_client@Z"}) 
	int jack_engine_takeover_timebase(Pointer jack_client_tPtr1);
	/**
	 * @return the current CPU load estimated by JACK.  This is a running<br>
	 * average of the time it takes to execute a full process cycle for<br>
	 * all clients as a percentage of the real time available per cycle<br>
	 * determined by the buffer size and sample rate.<br>
	 * Original signature : <code>float jack_cpu_load(jack_client_t*)</code><br>
	 * <i>native declaration : jack/jack.h:668</i>
	 */
	@Mangling({"_Z13jack_cpu_loadP12_jack_client", "?jack_cpu_load@@YAMPA12_jack_client@Z"}) 
	float jack_cpu_load(Pointer client);
	/**
	 * Create a new port for the client. This is an object used for moving<br>
	 * data of any type in or out of the client.  Ports may be connected<br>
	 * in various ways.<br>
	 * * Each port has a short name.  The port's full name contains the name<br>
	 * of the client concatenated with a colon (:) followed by its short<br>
	 * name.  The jack_port_name_size() is the maximum length of this full<br>
	 * name.  Exceeding that will cause the port registration to fail and<br>
	 * return NULL.<br>
	 * * The @a port_name must be unique among all ports owned by this client.<br>
	 * If the name is not unique, the registration will fail.<br>
	 * * All ports have a type, which may be any non-NULL and non-zero<br>
	 * length string, passed as an argument.  Some port types are built<br>
	 * into the JACK API, currently only JACK_DEFAULT_AUDIO_TYPE.<br>
	 * * @param client pointer to JACK client structure.<br>
	 * @param port_name non-empty short name for the new port (not<br>
	 * including the leading @a "client_name:"). Must be unique.<br>
	 * @param port_type port type name.  If longer than<br>
	 * jack_port_type_size(), only that many characters are significant.<br>
	 * @param flags @ref JackPortFlags bit mask.<br>
	 * @param buffer_size must be non-zero if this is not a built-in @a<br>
	 * port_type.  Otherwise, it is ignored.<br>
	 * * @return jack_port_t pointer on success, otherwise NULL.<br>
	 * Original signature : <code>jack_port_t* jack_port_register(jack_client_t*, const char*, const char*, unsigned long, unsigned long)</code><br>
	 * <i>native declaration : jack/jack.h:706</i><br>
	 * @deprecated use the safer methods {@link #jack_port_register(com.sun.jna.Pointer, java.lang.String, java.lang.String, com.sun.jna.NativeLong, com.sun.jna.NativeLong)} and {@link #jack_port_register(com.sun.jna.Pointer, com.sun.jna.Pointer, com.sun.jna.Pointer, com.sun.jna.NativeLong, com.sun.jna.NativeLong)} instead
	 */
	@Mangling({"_Z18jack_port_registerP12_jack_clientPKcPKcmm", "?jack_port_register@@YAPA10_jack_portPA12_jack_clientPADPADKK@Z"}) 
	@Deprecated 
	Pointer jack_port_register(Pointer client, Pointer port_name, Pointer port_type, NativeLong flags, NativeLong buffer_size);
	/**
	 * Create a new port for the client. This is an object used for moving<br>
	 * data of any type in or out of the client.  Ports may be connected<br>
	 * in various ways.<br>
	 * * Each port has a short name.  The port's full name contains the name<br>
	 * of the client concatenated with a colon (:) followed by its short<br>
	 * name.  The jack_port_name_size() is the maximum length of this full<br>
	 * name.  Exceeding that will cause the port registration to fail and<br>
	 * return NULL.<br>
	 * * The @a port_name must be unique among all ports owned by this client.<br>
	 * If the name is not unique, the registration will fail.<br>
	 * * All ports have a type, which may be any non-NULL and non-zero<br>
	 * length string, passed as an argument.  Some port types are built<br>
	 * into the JACK API, currently only JACK_DEFAULT_AUDIO_TYPE.<br>
	 * * @param client pointer to JACK client structure.<br>
	 * @param port_name non-empty short name for the new port (not<br>
	 * including the leading @a "client_name:"). Must be unique.<br>
	 * @param port_type port type name.  If longer than<br>
	 * jack_port_type_size(), only that many characters are significant.<br>
	 * @param flags @ref JackPortFlags bit mask.<br>
	 * @param buffer_size must be non-zero if this is not a built-in @a<br>
	 * port_type.  Otherwise, it is ignored.<br>
	 * * @return jack_port_t pointer on success, otherwise NULL.<br>
	 * Original signature : <code>jack_port_t* jack_port_register(jack_client_t*, const char*, const char*, unsigned long, unsigned long)</code><br>
	 * <i>native declaration : jack/jack.h:706</i>
	 */
	@Mangling({"_Z18jack_port_registerP12_jack_clientPKcPKcmm", "?jack_port_register@@YAPA10_jack_portPA12_jack_clientPADPADKK@Z"}) 
	Pointer jack_port_register(Pointer client, String port_name, String port_type, NativeLong flags, NativeLong buffer_size);
	/**
	 * Remove the port from the client, disconnecting any existing<br>
	 * connections.<br>
	 * * @return 0 on success, otherwise a non-zero error code<br>
	 * Original signature : <code>int jack_port_unregister(jack_client_t*, jack_port_t*)</code><br>
	 * <i>native declaration : jack/jack.h:718</i>
	 */
	@Mangling({"_Z20jack_port_unregisterP12_jack_clientP10_jack_port", "?jack_port_unregister@@YAHPA12_jack_clientPA10_jack_port@Z"}) 
	int jack_port_unregister(Pointer jack_client_tPtr1, Pointer jack_port_tPtr1);
	/**
	 * This returns a pointer to the memory area associated with the<br>
	 * specified port. For an output port, it will be a memory area<br>
	 * that can be written to; for an input port, it will be an area<br>
	 * containing the data from the port's connection(s), or<br>
	 * zero-filled. if there are multiple inbound connections, the data<br>
	 * will be mixed appropriately.<br>
	 * * FOR OUTPUT PORTS ONLY : DEPRECATED in Jack 2.0 !!<br>
	 * ---------------------------------------------------<br>
	 * You may cache the value returned, but only between calls to<br>
	 * your "blocksize" callback. For this reason alone, you should<br>
	 * either never cache the return value or ensure you have<br>
	 * a "blocksize" callback and be sure to invalidate the cached<br>
	 * address from there.<br>
	 * * Caching output ports is DEPRECATED in Jack 2.0, due to some new optimization (like "pipelining").<br>
	 * Port buffers have to be retrieved in each callback for proper functionning.<br>
	 * Original signature : <code>void* jack_port_get_buffer(jack_port_t*, uint32_t)</code><br>
	 * <i>native declaration : jack/jack.h:739</i>
	 */
	@Mangling({"_Z20jack_port_get_bufferP10_jack_port8uint32_t", "?jack_port_get_buffer@@YAPAXPA10_jack_port8uint32_t@Z"}) 
	Pointer jack_port_get_buffer(Pointer jack_port_tPtr1, int uint32_t1);
	/**
	 * @return the full name of the jack_port_t (including the @a<br>
	 * "client_name:" prefix).<br>
	 * * @see jack_port_name_size().<br>
	 * Original signature : <code>char* jack_port_name(const jack_port_t*)</code><br>
	 * <i>native declaration : jack/jack.h:747</i>
	 */
	@Mangling({"_Z14jack_port_namePK10_jack_port", "?jack_port_name@@YAQBDPA10_jack_port@Z"}) 
	String jack_port_name(Pointer port);
	/**
	 * @return the short name of the jack_port_t (not including the @a<br>
	 * "client_name:" prefix).<br>
	 * * @see jack_port_name_size().<br>
	 * Original signature : <code>char* jack_port_short_name(const jack_port_t*)</code><br>
	 * <i>native declaration : jack/jack.h:755</i>
	 */
	@Mangling({"_Z20jack_port_short_namePK10_jack_port", "?jack_port_short_name@@YAQBDPA10_jack_port@Z"}) 
	String jack_port_short_name(Pointer port);
	/**
	 * @return the @ref JackPortFlags of the jack_port_t.<br>
	 * Original signature : <code>int jack_port_flags(const jack_port_t*)</code><br>
	 * <i>native declaration : jack/jack.h:760</i>
	 */
	@Mangling({"_Z15jack_port_flagsPK10_jack_port", "?jack_port_flags@@YAHPA10_jack_port@Z"}) 
	int jack_port_flags(Pointer port);
	/**
	 * @return the @a port type, at most jack_port_type_size() characters<br>
	 * including a final NULL.<br>
	 * Original signature : <code>char* jack_port_type(const jack_port_t*)</code><br>
	 * <i>native declaration : jack/jack.h:766</i>
	 */
	@Mangling({"_Z14jack_port_typePK10_jack_port", "?jack_port_type@@YAQBDPA10_jack_port@Z"}) 
	String jack_port_type(Pointer port);
	/**
	 * @return the @a port type id.<br>
	 * Original signature : <code>jack_port_type_id_t jack_port_type_id(const jack_port_t*)</code><br>
	 * <i>native declaration : jack/jack.h:771</i>
	 */
	@Mangling({"_Z17jack_port_type_idPK10_jack_port", "?jack_port_type_id@@YA8uint32_tPA10_jack_port@Z"}) 
	int jack_port_type_id(Pointer port);
	/**
	 * @return TRUE if the jack_port_t belongs to the jack_client_t.<br>
	 * Original signature : <code>int jack_port_is_mine(const jack_client_t*, const jack_port_t*)</code><br>
	 * <i>native declaration : jack/jack.h:776</i>
	 */
	@Mangling({"_Z17jack_port_is_minePK12_jack_clientPK10_jack_port", "?jack_port_is_mine@@YAHPA12_jack_clientPA10_jack_port@Z"}) 
	int jack_port_is_mine(Pointer jack_client_tPtr1, Pointer port);
	/**
	 * @return number of connections to or from @a port.<br>
	 * * @pre The calling client must own @a port.<br>
	 * Original signature : <code>int jack_port_connected(const jack_port_t*)</code><br>
	 * <i>native declaration : jack/jack.h:783</i>
	 */
	@Mangling({"_Z19jack_port_connectedPK10_jack_port", "?jack_port_connected@@YAHPA10_jack_port@Z"}) 
	int jack_port_connected(Pointer port);
	/**
	 * @return TRUE if the locally-owned @a port is @b directly connected<br>
	 * to the @a port_name.<br>
	 * * @see jack_port_name_size()<br>
	 * Original signature : <code>int jack_port_connected_to(const jack_port_t*, const char*)</code><br>
	 * <i>native declaration : jack/jack.h:791</i><br>
	 * @deprecated use the safer methods {@link #jack_port_connected_to(com.sun.jna.Pointer, java.lang.String)} and {@link #jack_port_connected_to(com.sun.jna.Pointer, com.sun.jna.Pointer)} instead
	 */
	@Mangling({"_Z22jack_port_connected_toPK10_jack_portPKc", "?jack_port_connected_to@@YAHPA10_jack_portPAD@Z"}) 
	@Deprecated 
	int jack_port_connected_to(Pointer port, Pointer port_name);
	/**
	 * @return TRUE if the locally-owned @a port is @b directly connected<br>
	 * to the @a port_name.<br>
	 * * @see jack_port_name_size()<br>
	 * Original signature : <code>int jack_port_connected_to(const jack_port_t*, const char*)</code><br>
	 * <i>native declaration : jack/jack.h:791</i>
	 */
	@Mangling({"_Z22jack_port_connected_toPK10_jack_portPKc", "?jack_port_connected_to@@YAHPA10_jack_portPAD@Z"}) 
	int jack_port_connected_to(Pointer port, String port_name);
	/**
	 * @return a null-terminated array of full port names to which the @a<br>
	 * port is connected.  If none, returns NULL.<br>
	 * * The caller is responsible for calling jack_free(3) on any non-NULL<br>
	 * returned value.<br>
	 * * @param port locally owned jack_port_t pointer.<br>
	 * * @see jack_port_name_size(), jack_port_get_all_connections()<br>
	 * Original signature : <code>char** jack_port_get_connections(const jack_port_t*)</code><br>
	 * <i>native declaration : jack/jack.h:805</i>
	 */
	@Mangling({"_Z25jack_port_get_connectionsPK10_jack_port", "?jack_port_get_connections@@YAQBPADPA10_jack_port@Z"}) 
	PointerByReference jack_port_get_connections(Pointer port);
	/**
	 * @return a null-terminated array of full port names to which the @a<br>
	 * port is connected.  If none, returns NULL.<br>
	 * * The caller is responsible for calling jack_free(3) on any non-NULL<br>
	 * returned value.<br>
	 * * This differs from jack_port_get_connections() in two important<br>
	 * respects:<br>
	 * *     1) You may not call this function from code that is<br>
	 *          executed in response to a JACK event. For example,<br>
	 *          you cannot use it in a GraphReordered handler.<br>
	 * *     2) You need not be the owner of the port to get information<br>
	 *          about its connections.<br>
	 * * @see jack_port_name_size()<br>
	 * Original signature : <code>char** jack_port_get_all_connections(const jack_client_t*, const jack_port_t*)</code><br>
	 * <i>native declaration : jack/jack.h:826</i>
	 */
	@Mangling({"_Z29jack_port_get_all_connectionsPK12_jack_clientPK10_jack_port", "?jack_port_get_all_connections@@YAQBPADPA12_jack_clientPA10_jack_port@Z"}) 
	PointerByReference jack_port_get_all_connections(Pointer client, Pointer port);
	/**
	 * * @deprecated This function will be removed from a future version<br>
	 * of JACK. Do not use it. There is no replacement. It has<br>
	 * turned out to serve essentially no purpose in real-life<br>
	 * JACK clients.<br>
	 * Original signature : <code>int jack_port_tie(jack_port_t*, jack_port_t*)</code><br>
	 * <i>native declaration : jack/jack.h:836</i>
	 */
	@Mangling({"_Z13jack_port_tieP10_jack_portP10_jack_port", "?jack_port_tie@@YAHPA10_jack_portPA10_jack_port@Z"}) 
	int jack_port_tie(Pointer src, Pointer dst);
	/**
	 * * @deprecated This function will be removed from a future version<br>
	 * of JACK. Do not use it. There is no replacement. It has<br>
	 * turned out to serve essentially no purpose in real-life<br>
	 * JACK clients.<br>
	 * Original signature : <code>int jack_port_untie(jack_port_t*)</code><br>
	 * <i>native declaration : jack/jack.h:845</i>
	 */
	@Mangling({"_Z15jack_port_untieP10_jack_port", "?jack_port_untie@@YAHPA10_jack_port@Z"}) 
	int jack_port_untie(Pointer port);
	/**
	 * Modify a port's short name.  May be called at any time.  If the<br>
	 * resulting full name (including the @a "client_name:" prefix) is<br>
	 * longer than jack_port_name_size(), it will be truncated.<br>
	 * * @return 0 on success, otherwise a non-zero error code.<br>
	 * Original signature : <code>int jack_port_set_name(jack_port_t*, const char*)</code><br>
	 * <i>native declaration : jack/jack.h:854</i><br>
	 * @deprecated use the safer methods {@link #jack_port_set_name(com.sun.jna.Pointer, java.lang.String)} and {@link #jack_port_set_name(com.sun.jna.Pointer, com.sun.jna.Pointer)} instead
	 */
	@Mangling({"_Z18jack_port_set_nameP10_jack_portPKc", "?jack_port_set_name@@YAHPA10_jack_portPAD@Z"}) 
	@Deprecated 
	int jack_port_set_name(Pointer port, Pointer port_name);
	/**
	 * Modify a port's short name.  May be called at any time.  If the<br>
	 * resulting full name (including the @a "client_name:" prefix) is<br>
	 * longer than jack_port_name_size(), it will be truncated.<br>
	 * * @return 0 on success, otherwise a non-zero error code.<br>
	 * Original signature : <code>int jack_port_set_name(jack_port_t*, const char*)</code><br>
	 * <i>native declaration : jack/jack.h:854</i>
	 */
	@Mangling({"_Z18jack_port_set_nameP10_jack_portPKc", "?jack_port_set_name@@YAHPA10_jack_portPAD@Z"}) 
	int jack_port_set_name(Pointer port, String port_name);
	/**
	 * Set @a alias as an alias for @a port.  May be called at any time.<br>
	 * If the alias is longer than jack_port_name_size(), it will be truncated.<br>
	 * * After a successful call, and until JACK exits or<br>
	 * @function jack_port_unset_alias() is called, @alias may be<br>
	 * used as a alternate name for the port.<br>
	 * * Ports can have up to two aliases - if both are already<br>
	 * set, this function will return an error.<br>
	 * * @return 0 on success, otherwise a non-zero error code.<br>
	 * Original signature : <code>int jack_port_set_alias(jack_port_t*, const char*)</code><br>
	 * <i>native declaration : jack/jack.h:869</i><br>
	 * @deprecated use the safer methods {@link #jack_port_set_alias(com.sun.jna.Pointer, java.lang.String)} and {@link #jack_port_set_alias(com.sun.jna.Pointer, com.sun.jna.Pointer)} instead
	 */
	@Mangling({"_Z19jack_port_set_aliasP10_jack_portPKc", "?jack_port_set_alias@@YAHPA10_jack_portPAD@Z"}) 
	@Deprecated 
	int jack_port_set_alias(Pointer port, Pointer alias);
	/**
	 * Set @a alias as an alias for @a port.  May be called at any time.<br>
	 * If the alias is longer than jack_port_name_size(), it will be truncated.<br>
	 * * After a successful call, and until JACK exits or<br>
	 * @function jack_port_unset_alias() is called, @alias may be<br>
	 * used as a alternate name for the port.<br>
	 * * Ports can have up to two aliases - if both are already<br>
	 * set, this function will return an error.<br>
	 * * @return 0 on success, otherwise a non-zero error code.<br>
	 * Original signature : <code>int jack_port_set_alias(jack_port_t*, const char*)</code><br>
	 * <i>native declaration : jack/jack.h:869</i>
	 */
	@Mangling({"_Z19jack_port_set_aliasP10_jack_portPKc", "?jack_port_set_alias@@YAHPA10_jack_portPAD@Z"}) 
	int jack_port_set_alias(Pointer port, String alias);
	/**
	 * Remove @a alias as an alias for @a port.  May be called at any time.<br>
	 * * After a successful call, @a alias can no longer be<br>
	 * used as a alternate name for the port.<br>
	 * * @return 0 on success, otherwise a non-zero error code.<br>
	 * Original signature : <code>int jack_port_unset_alias(jack_port_t*, const char*)</code><br>
	 * <i>native declaration : jack/jack.h:879</i><br>
	 * @deprecated use the safer methods {@link #jack_port_unset_alias(com.sun.jna.Pointer, java.lang.String)} and {@link #jack_port_unset_alias(com.sun.jna.Pointer, com.sun.jna.Pointer)} instead
	 */
	@Mangling({"_Z21jack_port_unset_aliasP10_jack_portPKc", "?jack_port_unset_alias@@YAHPA10_jack_portPAD@Z"}) 
	@Deprecated 
	int jack_port_unset_alias(Pointer port, Pointer alias);
	/**
	 * Remove @a alias as an alias for @a port.  May be called at any time.<br>
	 * * After a successful call, @a alias can no longer be<br>
	 * used as a alternate name for the port.<br>
	 * * @return 0 on success, otherwise a non-zero error code.<br>
	 * Original signature : <code>int jack_port_unset_alias(jack_port_t*, const char*)</code><br>
	 * <i>native declaration : jack/jack.h:879</i>
	 */
	@Mangling({"_Z21jack_port_unset_aliasP10_jack_portPKc", "?jack_port_unset_alias@@YAHPA10_jack_portPAD@Z"}) 
	int jack_port_unset_alias(Pointer port, String alias);
	/**
	 * Get any aliases known for @port.<br>
	 * * @return the number of aliases discovered for the port<br>
	 * Original signature : <code>int jack_port_get_aliases(const jack_port_t*, char*[2])</code><br>
	 * <i>native declaration : jack/jack.h:886</i><br>
	 * @deprecated use the safer methods {@link #jack_port_get_aliases(com.sun.jna.Pointer, java.nio.ByteBuffer[])} and {@link #jack_port_get_aliases(com.sun.jna.Pointer, com.sun.jna.ptr.PointerByReference)} instead
	 */
	@Mangling({"_Z21jack_port_get_aliasesPK10_jack_portPPc", "?jack_port_get_aliases@@YAHPA10_jack_portQAPAD@Z"}) 
	@Deprecated 
	int jack_port_get_aliases(Pointer port, PointerByReference aliases);
	/**
	 * Get any aliases known for @port.<br>
	 * * @return the number of aliases discovered for the port<br>
	 * Original signature : <code>int jack_port_get_aliases(const jack_port_t*, char*[2])</code><br>
	 * <i>native declaration : jack/jack.h:886</i>
	 */
	@Mangling({"_Z21jack_port_get_aliasesPK10_jack_portPPc", "?jack_port_get_aliases@@YAHPA10_jack_portQAPAD@Z"}) 
	int jack_port_get_aliases(Pointer port, ByteBuffer aliases[]);
	/**
	 * If @ref JackPortCanMonitor is set for this @a port, turn input<br>
	 * monitoring on or off.  Otherwise, do nothing.<br>
	 * Original signature : <code>int jack_port_request_monitor(jack_port_t*, int)</code><br>
	 * <i>native declaration : jack/jack.h:892</i>
	 */
	@Mangling({"_Z25jack_port_request_monitorP10_jack_porti", "?jack_port_request_monitor@@YAHPA10_jack_portH@Z"}) 
	int jack_port_request_monitor(Pointer port, int onoff);
	/**
	 * If @ref JackPortCanMonitor is set for this @a port_name, turn input<br>
	 * monitoring on or off.  Otherwise, do nothing.<br>
	 * * @return 0 on success, otherwise a non-zero error code.<br>
	 * * @see jack_port_name_size()<br>
	 * Original signature : <code>int jack_port_request_monitor_by_name(jack_client_t*, const char*, int)</code><br>
	 * <i>native declaration : jack/jack.h:902</i><br>
	 * @deprecated use the safer methods {@link #jack_port_request_monitor_by_name(com.sun.jna.Pointer, java.lang.String, int)} and {@link #jack_port_request_monitor_by_name(com.sun.jna.Pointer, com.sun.jna.Pointer, int)} instead
	 */
	@Mangling({"_Z33jack_port_request_monitor_by_nameP12_jack_clientPKci", "?jack_port_request_monitor_by_name@@YAHPA12_jack_clientPADH@Z"}) 
	@Deprecated 
	int jack_port_request_monitor_by_name(Pointer client, Pointer port_name, int onoff);
	/**
	 * If @ref JackPortCanMonitor is set for this @a port_name, turn input<br>
	 * monitoring on or off.  Otherwise, do nothing.<br>
	 * * @return 0 on success, otherwise a non-zero error code.<br>
	 * * @see jack_port_name_size()<br>
	 * Original signature : <code>int jack_port_request_monitor_by_name(jack_client_t*, const char*, int)</code><br>
	 * <i>native declaration : jack/jack.h:902</i>
	 */
	@Mangling({"_Z33jack_port_request_monitor_by_nameP12_jack_clientPKci", "?jack_port_request_monitor_by_name@@YAHPA12_jack_clientPADH@Z"}) 
	int jack_port_request_monitor_by_name(Pointer client, String port_name, int onoff);
	/**
	 * If @ref JackPortCanMonitor is set for a port, this function turns<br>
	 * on input monitoring if it was off, and turns it off if only one<br>
	 * request has been made to turn it on.  Otherwise it does nothing.<br>
	 * * @return 0 on success, otherwise a non-zero error code<br>
	 * Original signature : <code>int jack_port_ensure_monitor(jack_port_t*, int)</code><br>
	 * <i>native declaration : jack/jack.h:912</i>
	 */
	@Mangling({"_Z24jack_port_ensure_monitorP10_jack_porti", "?jack_port_ensure_monitor@@YAHPA10_jack_portH@Z"}) 
	int jack_port_ensure_monitor(Pointer port, int onoff);
	/**
	 * @return TRUE if input monitoring has been requested for @a port.<br>
	 * Original signature : <code>int jack_port_monitoring_input(jack_port_t*)</code><br>
	 * <i>native declaration : jack/jack.h:917</i>
	 */
	@Mangling({"_Z26jack_port_monitoring_inputP10_jack_port", "?jack_port_monitoring_input@@YAHPA10_jack_port@Z"}) 
	int jack_port_monitoring_input(Pointer port);
	/**
	 * Establish a connection between two ports.<br>
	 * * When a connection exists, data written to the source port will<br>
	 * be available to be read at the destination port.<br>
	 * * @pre The port types must be identical.<br>
	 * * @pre The @ref JackPortFlags of the @a source_port must include @ref<br>
	 * JackPortIsOutput.<br>
	 * * @pre The @ref JackPortFlags of the @a destination_port must include<br>
	 * @ref JackPortIsInput.<br>
	 * * @return 0 on success, EEXIST if the connection is already made,<br>
	 * otherwise a non-zero error code<br>
	 * Original signature : <code>int jack_connect(jack_client_t*, const char*, const char*)</code><br>
	 * <i>native declaration : jack/jack.h:936</i><br>
	 * @deprecated use the safer methods {@link #jack_connect(com.sun.jna.Pointer, java.lang.String, java.lang.String)} and {@link #jack_connect(com.sun.jna.Pointer, com.sun.jna.Pointer, com.sun.jna.Pointer)} instead
	 */
	@Mangling({"_Z12jack_connectP12_jack_clientPKcPKc", "?jack_connect@@YAHPA12_jack_clientPADPAD@Z"}) 
	@Deprecated 
	int jack_connect(Pointer jack_client_tPtr1, Pointer source_port, Pointer destination_port);
	/**
	 * Establish a connection between two ports.<br>
	 * * When a connection exists, data written to the source port will<br>
	 * be available to be read at the destination port.<br>
	 * * @pre The port types must be identical.<br>
	 * * @pre The @ref JackPortFlags of the @a source_port must include @ref<br>
	 * JackPortIsOutput.<br>
	 * * @pre The @ref JackPortFlags of the @a destination_port must include<br>
	 * @ref JackPortIsInput.<br>
	 * * @return 0 on success, EEXIST if the connection is already made,<br>
	 * otherwise a non-zero error code<br>
	 * Original signature : <code>int jack_connect(jack_client_t*, const char*, const char*)</code><br>
	 * <i>native declaration : jack/jack.h:936</i>
	 */
	@Mangling({"_Z12jack_connectP12_jack_clientPKcPKc", "?jack_connect@@YAHPA12_jack_clientPADPAD@Z"}) 
	int jack_connect(Pointer jack_client_tPtr1, String source_port, String destination_port);
	/**
	 * Remove a connection between two ports.<br>
	 * * @pre The port types must be identical.<br>
	 * * @pre The @ref JackPortFlags of the @a source_port must include @ref<br>
	 * JackPortIsOutput.<br>
	 * * @pre The @ref JackPortFlags of the @a destination_port must include<br>
	 * @ref JackPortIsInput.<br>
	 * * @return 0 on success, otherwise a non-zero error code<br>
	 * Original signature : <code>int jack_disconnect(jack_client_t*, const char*, const char*)</code><br>
	 * <i>native declaration : jack/jack.h:953</i><br>
	 * @deprecated use the safer methods {@link #jack_disconnect(com.sun.jna.Pointer, java.lang.String, java.lang.String)} and {@link #jack_disconnect(com.sun.jna.Pointer, com.sun.jna.Pointer, com.sun.jna.Pointer)} instead
	 */
	@Mangling({"_Z15jack_disconnectP12_jack_clientPKcPKc", "?jack_disconnect@@YAHPA12_jack_clientPADPAD@Z"}) 
	@Deprecated 
	int jack_disconnect(Pointer jack_client_tPtr1, Pointer source_port, Pointer destination_port);
	/**
	 * Remove a connection between two ports.<br>
	 * * @pre The port types must be identical.<br>
	 * * @pre The @ref JackPortFlags of the @a source_port must include @ref<br>
	 * JackPortIsOutput.<br>
	 * * @pre The @ref JackPortFlags of the @a destination_port must include<br>
	 * @ref JackPortIsInput.<br>
	 * * @return 0 on success, otherwise a non-zero error code<br>
	 * Original signature : <code>int jack_disconnect(jack_client_t*, const char*, const char*)</code><br>
	 * <i>native declaration : jack/jack.h:953</i>
	 */
	@Mangling({"_Z15jack_disconnectP12_jack_clientPKcPKc", "?jack_disconnect@@YAHPA12_jack_clientPADPAD@Z"}) 
	int jack_disconnect(Pointer jack_client_tPtr1, String source_port, String destination_port);
	/**
	 * Perform the same function as jack_disconnect() using port handles<br>
	 * rather than names.  This avoids the name lookup inherent in the<br>
	 * name-based version.<br>
	 * * Clients connecting their own ports are likely to use this function,<br>
	 * while generic connection clients (e.g. patchbays) would use<br>
	 * jack_disconnect().<br>
	 * Original signature : <code>int jack_port_disconnect(jack_client_t*, jack_port_t*)</code><br>
	 * <i>native declaration : jack/jack.h:966</i>
	 */
	@Mangling({"_Z20jack_port_disconnectP12_jack_clientP10_jack_port", "?jack_port_disconnect@@YAHPA12_jack_clientPA10_jack_port@Z"}) 
	int jack_port_disconnect(Pointer jack_client_tPtr1, Pointer jack_port_tPtr1);
	/**
	 * @return the maximum number of characters in a full JACK port name<br>
	 * including the final NULL character.  This value is a constant.<br>
	 * * A port's full name contains the owning client name concatenated<br>
	 * with a colon (:) followed by its short name and a NULL<br>
	 * character.<br>
	 * Original signature : <code>int jack_port_name_size()</code><br>
	 * <i>native declaration : jack/jack.h:976</i>
	 */
	@Mangling({"_Z19jack_port_name_sizev", "?jack_port_name_size@@YAHXZ"}) 
	int jack_port_name_size();
	/**
	 * @return the maximum number of characters in a JACK port type name<br>
	 * including the final NULL character.  This value is a constant.<br>
	 * Original signature : <code>int jack_port_type_size()</code><br>
	 * <i>native declaration : jack/jack.h:982</i>
	 */
	@Mangling({"_Z19jack_port_type_sizev", "?jack_port_type_size@@YAHXZ"}) 
	int jack_port_type_size();
	/**
	 * @return the buffersize of a port of type @arg port_type.<br>
	 * * this function may only be called in a buffer_size callback.<br>
	 * Original signature : <code>size_t jack_port_type_get_buffer_size(jack_client_t*, const char*)</code><br>
	 * <i>native declaration : jack/jack.h:989</i><br>
	 * @deprecated use the safer methods {@link #jack_port_type_get_buffer_size(com.sun.jna.Pointer, java.lang.String)} and {@link #jack_port_type_get_buffer_size(com.sun.jna.Pointer, com.sun.jna.Pointer)} instead
	 */
	@Mangling({"_Z30jack_port_type_get_buffer_sizeP12_jack_clientPKc", "?jack_port_type_get_buffer_size@@YA6size_tPA12_jack_clientPAD@Z"}) 
	@Deprecated 
	NativeSize jack_port_type_get_buffer_size(Pointer client, Pointer port_type);
	/**
	 * @return the buffersize of a port of type @arg port_type.<br>
	 * * this function may only be called in a buffer_size callback.<br>
	 * Original signature : <code>size_t jack_port_type_get_buffer_size(jack_client_t*, const char*)</code><br>
	 * <i>native declaration : jack/jack.h:989</i>
	 */
	@Mangling({"_Z30jack_port_type_get_buffer_sizeP12_jack_clientPKc", "?jack_port_type_get_buffer_size@@YA6size_tPA12_jack_clientPAD@Z"}) 
	NativeSize jack_port_type_get_buffer_size(Pointer client, String port_type);
	/**
	 * The port latency is zero by default. Clients that control<br>
	 * physical hardware with non-zero latency should call this<br>
	 * to set the latency to its correct value. Note that the value<br>
	 * should include any systemic latency present "outside" the<br>
	 * physical hardware controlled by the client. For example,<br>
	 * for a client controlling a digital audio interface connected<br>
	 * to an external digital converter, the latency setting should<br>
	 * include both buffering by the audio interface *and* the converter.<br>
	 * * @deprecated This method will be removed in the next major<br>
	 * release of JACK. It should not be used in new code, and should<br>
	 * be replaced by a latency callback that calls @ref<br>
	 * jack_port_set_latency_range().<br>
	 * Original signature : <code>void jack_port_set_latency(jack_port_t*, uint32_t)</code><br>
	 * <i>native declaration : jack/jack.h:1057</i>
	 */
	@Mangling({"_Z21jack_port_set_latencyP10_jack_port8uint32_t", "?jack_port_set_latency@@YAXPA10_jack_port8uint32_t@Z"}) 
	void jack_port_set_latency(Pointer jack_port_tPtr1, int uint32_t1);
	/**
	 * return the latency range defined by @a mode for<br>
	 * @a port, in frames.<br>
	 * * See @ref LatencyFunctions for the definition of each latency value.<br>
	 * * This is normally used in the LatencyCallback.<br>
	 * and therefor safe to execute from callbacks.<br>
	 * Original signature : <code>void jack_port_get_latency_range(jack_port_t*, jack_latency_callback_mode_t, jack_latency_range_t*)</code><br>
	 * <i>native declaration : jack/jack.h:1068</i><br>
	 * @param mode @see jack_latency_callback_mode_t
	 */
	@Mangling({"_Z27jack_port_get_latency_rangeP10_jack_port28jack_latency_callback_mode_tP19_jack_latency_range", "?jack_port_get_latency_range@@YAXPA10_jack_port28jack_latency_callback_mode_tPA19_jack_latency_range@Z"}) 
	void jack_port_get_latency_range(Pointer port, int mode, _jack_latency_range range);
	/**
	 * set the minimum and maximum latencies defined by<br>
	 * @a mode for @a port, in frames.<br>
	 * * See @ref LatencyFunctions for the definition of each latency value.<br>
	 * * This function should ONLY be used inside a latency<br>
	 * callback. The client should determine the current<br>
	 * value of the latency using @ref jack_port_get_latency_range()<br>
	 * (called using the same mode as @a mode)<br>
	 * and then add some number of frames to that reflects<br>
	 * latency added by the client.<br>
	 * * How much latency a client adds will vary<br>
	 * dramatically. For most clients, the answer is zero<br>
	 * and there is no reason for them to register a latency<br>
	 * callback and thus they should never call this<br>
	 * function.<br>
	 * * More complex clients that take an input signal,<br>
	 * transform it in some way and output the result but<br>
	 * not during the same process() callback will<br>
	 * generally know a single constant value to add<br>
	 * to the value returned by @ref jack_port_get_latency_range().<br>
	 * * Such clients would register a latency callback (see<br>
	 * @ref jack_set_latency_callback) and must know what input<br>
	 * ports feed which output ports as part of their<br>
	 * internal state. Their latency callback will update<br>
	 * the ports' latency values appropriately.<br>
	 * * A pseudo-code example will help. The @a mode argument to the latency<br>
	 * callback will determine whether playback or capture<br>
	 * latency is being set. The callback will use<br>
	 * @ref jack_port_set_latency_range() as follows:<br>
	 * * \code<br>
	 * jack_latency_range_t range;<br>
	 * if (mode == JackPlaybackLatency) {<br>
	 *  foreach input_port in (all self-registered port) {<br>
	 *   jack_port_get_latency_range (port_feeding_input_port, JackPlaybackLatency, &range);<br>
	 *   range.min += min_delay_added_as_signal_flows_from port_feeding to input_port;<br>
	 *   range.max += max_delay_added_as_signal_flows_from port_feeding to input_port;<br>
	 *   jack_port_set_latency_range (input_port, JackPlaybackLatency, &range);<br>
	 *  }<br>
	 * } else if (mode == JackCaptureLatency) {<br>
	 *  foreach output_port in (all self-registered port) {<br>
	 *   jack_port_get_latency_range (port_fed_by_output_port, JackCaptureLatency, &range);<br>
	 *   range.min += min_delay_added_as_signal_flows_from_output_port_to_fed_by_port;<br>
	 *   range.max += max_delay_added_as_signal_flows_from_output_port_to_fed_by_port;<br>
	 *   jack_port_set_latency_range (output_port, JackCaptureLatency, &range);<br>
	 *  }<br>
	 * }<br>
	 * \endcode<br>
	 * * In this relatively simple pseudo-code example, it is assumed that<br>
	 * each input port or output is connected to only 1 output or input<br>
	 * port respectively.<br>
	 * * If a port is connected to more than 1 other port, then the<br>
	 * range.min and range.max values passed to @ref<br>
	 * jack_port_set_latency_range() should reflect the minimum and<br>
	 * maximum values across all connected ports.<br>
	 * * See the description of @ref jack_set_latency_callback for more<br>
	 * information.<br>
	 * Original signature : <code>void jack_port_set_latency_range(jack_port_t*, jack_latency_callback_mode_t, jack_latency_range_t*)</code><br>
	 * <i>native declaration : jack/jack.h:1137</i><br>
	 * @param mode @see jack_latency_callback_mode_t
	 */
	@Mangling({"_Z27jack_port_set_latency_rangeP10_jack_port28jack_latency_callback_mode_tP19_jack_latency_range", "?jack_port_set_latency_range@@YAXPA10_jack_port28jack_latency_callback_mode_tPA19_jack_latency_range@Z"}) 
	void jack_port_set_latency_range(Pointer port, int mode, _jack_latency_range range);
	/**
	 * Request a complete recomputation of all port latencies. This<br>
	 * can be called by a client that has just changed the internal<br>
	 * latency of its port using  jack_port_set_latency<br>
	 * and wants to ensure that all signal pathways in the graph<br>
	 * are updated with respect to the values that will be returned<br>
	 * by  jack_port_get_total_latency. It allows a client<br>
	 * to change multiple port latencies without triggering a<br>
	 * recompute for each change.<br>
	 * * @return zero for successful execution of the request. non-zero<br>
	 *         otherwise.<br>
	 * Original signature : <code>int jack_recompute_total_latencies(jack_client_t*)</code><br>
	 * <i>native declaration : jack/jack.h:1152</i>
	 */
	@Mangling({"_Z30jack_recompute_total_latenciesP12_jack_client", "?jack_recompute_total_latencies@@YAHPA12_jack_client@Z"}) 
	int jack_recompute_total_latencies(Pointer jack_client_tPtr1);
	/**
	 * @return the time (in frames) between data being available or<br>
	 * delivered at/to a port, and the time at which it arrived at or is<br>
	 * delivered to the "other side" of the port.  E.g. for a physical<br>
	 * audio output port, this is the time between writing to the port and<br>
	 * when the signal will leave the connector.  For a physical audio<br>
	 * input port, this is the time between the sound arriving at the<br>
	 * connector and the corresponding frames being readable from the<br>
	 * port.<br>
	 * * @deprecated This method will be removed in the next major<br>
	 * release of JACK. It should not be used in new code, and should<br>
	 * be replaced by jack_port_get_latency_range() in any existing<br>
	 * use cases.<br>
	 * Original signature : <code>uint32_t jack_port_get_latency(jack_port_t*)</code><br>
	 * <i>native declaration : jack/jack.h:1169</i>
	 */
	@Mangling({"_Z21jack_port_get_latencyP10_jack_port", "?jack_port_get_latency@@YA8uint32_tPA10_jack_port@Z"}) 
	int jack_port_get_latency(Pointer port);
	/**
	 * The maximum of the sum of the latencies in every<br>
	 * connection path that can be drawn between the port and other<br>
	 * ports with the @ref JackPortIsTerminal flag set.<br>
	 * * @deprecated This method will be removed in the next major<br>
	 * release of JACK. It should not be used in new code, and should<br>
	 * be replaced by jack_port_get_latency_range() in any existing<br>
	 * use cases.<br>
	 * Original signature : <code>uint32_t jack_port_get_total_latency(jack_client_t*, jack_port_t*)</code><br>
	 * <i>native declaration : jack/jack.h:1181</i>
	 */
	@Mangling({"_Z27jack_port_get_total_latencyP12_jack_clientP10_jack_port", "?jack_port_get_total_latency@@YA8uint32_tPA12_jack_clientPA10_jack_port@Z"}) 
	int jack_port_get_total_latency(Pointer jack_client_tPtr1, Pointer port);
	/**
	 * Request a complete recomputation of a port's total latency. This<br>
	 * can be called by a client that has just changed the internal<br>
	 * latency of its port using  jack_port_set_latency<br>
	 * and wants to ensure that all signal pathways in the graph<br>
	 * are updated with respect to the values that will be returned<br>
	 * by  jack_port_get_total_latency.<br>
	 * * @return zero for successful execution of the request. non-zero<br>
	 *         otherwise.<br>
	 * * @deprecated This method will be removed in the next major<br>
	 * release of JACK. It should not be used in new code, and should<br>
	 * be replaced by jack_recompute_total_latencies() in any existing<br>
	 * use cases.<br>
	 * Original signature : <code>int jack_recompute_total_latency(jack_client_t*, jack_port_t*)</code><br>
	 * <i>native declaration : jack/jack.h:1200</i>
	 */
	@Mangling({"_Z28jack_recompute_total_latencyP12_jack_clientP10_jack_port", "?jack_recompute_total_latency@@YAHPA12_jack_clientPA10_jack_port@Z"}) 
	int jack_recompute_total_latency(Pointer jack_client_tPtr1, Pointer port);
	/**
	 * @param port_name_pattern A regular expression used to select<br>
	 * ports by name.  If NULL or of zero length, no selection based<br>
	 * on name will be carried out.<br>
	 * @param type_name_pattern A regular expression used to select<br>
	 * ports by type.  If NULL or of zero length, no selection based<br>
	 * on type will be carried out.<br>
	 * @param flags A value used to select ports by their flags.<br>
	 * If zero, no selection based on flags will be carried out.<br>
	 * * @return a NULL-terminated array of ports that match the specified<br>
	 * arguments.  The caller is responsible for calling jack_free(3) any<br>
	 * non-NULL returned value.<br>
	 * * @see jack_port_name_size(), jack_port_type_size()<br>
	 * Original signature : <code>char** jack_get_ports(jack_client_t*, const char*, const char*, unsigned long)</code><br>
	 * <i>native declaration : jack/jack.h:1225</i><br>
	 * @deprecated use the safer methods {@link #jack_get_ports(com.sun.jna.Pointer, java.lang.String, java.lang.String, com.sun.jna.NativeLong)} and {@link #jack_get_ports(com.sun.jna.Pointer, com.sun.jna.Pointer, com.sun.jna.Pointer, com.sun.jna.NativeLong)} instead
	 */
	@Mangling({"_Z14jack_get_portsP12_jack_clientPKcPKcm", "?jack_get_ports@@YAQBPADPA12_jack_clientPADPADK@Z"}) 
	@Deprecated 
	PointerByReference jack_get_ports(Pointer jack_client_tPtr1, Pointer port_name_pattern, Pointer type_name_pattern, NativeLong flags);
	/**
	 * @param port_name_pattern A regular expression used to select<br>
	 * ports by name.  If NULL or of zero length, no selection based<br>
	 * on name will be carried out.<br>
	 * @param type_name_pattern A regular expression used to select<br>
	 * ports by type.  If NULL or of zero length, no selection based<br>
	 * on type will be carried out.<br>
	 * @param flags A value used to select ports by their flags.<br>
	 * If zero, no selection based on flags will be carried out.<br>
	 * * @return a NULL-terminated array of ports that match the specified<br>
	 * arguments.  The caller is responsible for calling jack_free(3) any<br>
	 * non-NULL returned value.<br>
	 * * @see jack_port_name_size(), jack_port_type_size()<br>
	 * Original signature : <code>char** jack_get_ports(jack_client_t*, const char*, const char*, unsigned long)</code><br>
	 * <i>native declaration : jack/jack.h:1225</i>
	 */
	@Mangling({"_Z14jack_get_portsP12_jack_clientPKcPKcm", "?jack_get_ports@@YAQBPADPA12_jack_clientPADPADK@Z"}) 
	PointerByReference jack_get_ports(Pointer jack_client_tPtr1, String port_name_pattern, String type_name_pattern, NativeLong flags);
	/**
	 * @return address of the jack_port_t named @a port_name.<br>
	 * * @see jack_port_name_size()<br>
	 * Original signature : <code>jack_port_t* jack_port_by_name(jack_client_t*, const char*)</code><br>
	 * <i>native declaration : jack/jack.h:1235</i><br>
	 * @deprecated use the safer methods {@link #jack_port_by_name(com.sun.jna.Pointer, java.lang.String)} and {@link #jack_port_by_name(com.sun.jna.Pointer, com.sun.jna.Pointer)} instead
	 */
	@Mangling({"_Z17jack_port_by_nameP12_jack_clientPKc", "?jack_port_by_name@@YAPA10_jack_portPA12_jack_clientPAD@Z"}) 
	@Deprecated 
	Pointer jack_port_by_name(Pointer jack_client_tPtr1, Pointer port_name);
	/**
	 * @return address of the jack_port_t named @a port_name.<br>
	 * * @see jack_port_name_size()<br>
	 * Original signature : <code>jack_port_t* jack_port_by_name(jack_client_t*, const char*)</code><br>
	 * <i>native declaration : jack/jack.h:1235</i>
	 */
	@Mangling({"_Z17jack_port_by_nameP12_jack_clientPKc", "?jack_port_by_name@@YAPA10_jack_portPA12_jack_clientPAD@Z"}) 
	Pointer jack_port_by_name(Pointer jack_client_tPtr1, String port_name);
	/**
	 * @return address of the jack_port_t of a @a port_id.<br>
	 * Original signature : <code>jack_port_t* jack_port_by_id(jack_client_t*, jack_port_id_t)</code><br>
	 * <i>native declaration : jack/jack.h:1240</i>
	 */
	@Mangling({"_Z15jack_port_by_idP12_jack_client8uint32_t", "?jack_port_by_id@@YAPA10_jack_portPA12_jack_client8uint32_t@Z"}) 
	Pointer jack_port_by_id(Pointer client, int port_id);
	/**
	 * @return the estimated time in frames that has passed since the JACK<br>
	 * server began the current process cycle.<br>
	 * Original signature : <code>uint32_t jack_frames_since_cycle_start(const jack_client_t*)</code><br>
	 * <i>native declaration : jack/jack.h:1258</i>
	 */
	@Mangling({"_Z29jack_frames_since_cycle_startPK12_jack_client", "?jack_frames_since_cycle_start@@YA8uint32_tPA12_jack_client@Z"}) 
	int jack_frames_since_cycle_start(Pointer jack_client_tPtr1);
	/**
	 * @return the estimated current time in frames.<br>
	 * This function is intended for use in other threads (not the process<br>
	 * callback).  The return value can be compared with the value of<br>
	 * jack_last_frame_time to relate time in other threads to JACK time.<br>
	 * Original signature : <code>uint32_t jack_frame_time(const jack_client_t*)</code><br>
	 * <i>native declaration : jack/jack.h:1266</i>
	 */
	@Mangling({"_Z15jack_frame_timePK12_jack_client", "?jack_frame_time@@YA8uint32_tPA12_jack_client@Z"}) 
	int jack_frame_time(Pointer jack_client_tPtr1);
	/**
	 * @return the precise time at the start of the current process cycle.<br>
	 * This function may only be used from the process callback, and can<br>
	 * be used to interpret timestamps generated by jack_frame_time() in<br>
	 * other threads with respect to the current process cycle.<br>
	 * * This is the only jack time function that returns exact time:<br>
	 * when used during the process callback it always returns the same<br>
	 * value (until the next process callback, where it will return<br>
	 * that value + nframes, etc).  The return value is guaranteed to be<br>
	 * monotonic and linear in this fashion unless an xrun occurs.<br>
	 * If an xrun occurs, clients must check this value again, as time<br>
	 * may have advanced in a non-linear way (e.g. cycles may have been skipped).<br>
	 * Original signature : <code>uint32_t jack_last_frame_time(const jack_client_t*)</code><br>
	 * <i>native declaration : jack/jack.h:1282</i>
	 */
	@Mangling({"_Z20jack_last_frame_timePK12_jack_client", "?jack_last_frame_time@@YA8uint32_tPA12_jack_client@Z"}) 
	int jack_last_frame_time(Pointer client);
	/**
	 * @return the estimated time in microseconds of the specified frame time<br>
	 * Original signature : <code>uint64_t jack_frames_to_time(const jack_client_t*, uint32_t)</code><br>
	 * <i>native declaration : jack/jack.h:1287</i>
	 */
	@Mangling({"_Z19jack_frames_to_timePK12_jack_client8uint32_t", "?jack_frames_to_time@@YA8uint64_tPA12_jack_client8uint32_t@Z"}) 
	long jack_frames_to_time(Pointer client, int uint32_t1);
	/**
	 * @return the estimated time in frames for the specified system time.<br>
	 * Original signature : <code>uint32_t uint64_to_frames(const jack_client_t*, uint64_t)</code><br>
	 * <i>native declaration : jack/jack.h:1292</i>
	 */
	@Mangling({"_Z16uint64_to_framesPK12_jack_client8uint64_t", "?uint64_to_frames@@YA8uint32_tPA12_jack_client8uint64_t@Z"}) 
	int uint64_to_frames(Pointer client, long uint64_t1);
	/**
	 * @return return JACK's current system time in microseconds,<br>
	 *         using the JACK clock source.<br>
	 * * The value returned is guaranteed to be monotonic, but not linear.<br>
	 * Original signature : <code>uint64_t jack_get_time()</code><br>
	 * <i>native declaration : jack/jack.h:1300</i>
	 */
	@Mangling({"_Z13jack_get_timev", "?jack_get_time@@YA8uint64_tXZ"}) 
	long jack_get_time();
	/**
	 * Set the @ref jack_error_callback for error message display.<br>
	 * Set it to NULL to restore default_jack_error_callback function.<br>
	 * * The JACK library provides two built-in callbacks for this purpose:<br>
	 * default_jack_error_callback() and silent_jack_error_callback().<br>
	 * Original signature : <code>void jack_set_error_function(jack_set_error_function_arg1_func_callback)</code><br>
	 * <i>native declaration : jack/jack.h:1326</i>
	 */
	@Mangling({"_Z23jack_set_error_functionPFvPKcE", "?jack_set_error_function@@YAXPFXPAD@E@Z"}) 
	void jack_set_error_function(JackLibrary.jack_set_error_function_arg1_func_callback arg1);
	/**
	 * Set the @ref jack_info_callback for info message display.<br>
	 * Set it to NULL to restore default_jack_info_callback function.<br>
	 * * The JACK library provides two built-in callbacks for this purpose:<br>
	 * default_jack_info_callback() and silent_jack_info_callback().<br>
	 * Original signature : <code>void jack_set_info_function(jack_set_info_function_arg1_func_callback)</code><br>
	 * <i>native declaration : jack/jack.h:1345</i>
	 */
	@Mangling({"_Z22jack_set_info_functionPFvPKcE", "?jack_set_info_function@@YAXPFXPAD@E@Z"}) 
	void jack_set_info_function(JackLibrary.jack_set_info_function_arg1_func_callback arg1);
	/**
	 * The free function to be used on memory returned by jack_port_get_connections,<br>
	 * jack_port_get_all_connections and jack_get_ports functions.<br>
	 * This is MANDATORY on Windows when otherwise all nasty runtime version related crashes can occur.<br>
	 * Developers are strongly encouraged to use this function instead of the standard "free" function in new code.<br>
	 * Original signature : <code>void jack_free(void*)</code><br>
	 * <i>native declaration : jack/jack.h:1356</i>
	 */
	@Mangling({"_Z9jack_freePv", "?jack_free@@YAXPAX@Z"}) 
	void jack_free(Pointer ptr);
	/**
	 * Get number of events in a port buffer.<br>
	 * * @param port_buffer Port buffer from which to retrieve event.<br>
	 * @return number of events inside @a port_buffer<br>
	 * Original signature : <code>uint32_t jack_midi_get_event_count(void*)</code><br>
	 * <i>native declaration : jack/midiport.h:53</i>
	 */
	@Mangling({"_Z25jack_midi_get_event_countPv", "?jack_midi_get_event_count@@YA8uint32_tPAX@Z"}) 
	int jack_midi_get_event_count(Pointer port_buffer);
	/**
	 * Get a MIDI event from an event port buffer.<br>
	 * * Jack MIDI is normalised, the MIDI event returned by this function is<br>
	 * guaranteed to be a complete MIDI event (the status byte will always be<br>
	 * present, and no realtime events will interspered with the event).<br>
	 * * @param event Event structure to store retrieved event in.<br>
	 * @param port_buffer Port buffer from which to retrieve event.<br>
	 * @param event_index Index of event to retrieve.<br>
	 * @return 0 on success, ENODATA if buffer is empty.<br>
	 * Original signature : <code>int jack_midi_event_get(jack_midi_event_t*, void*, uint32_t)</code><br>
	 * <i>native declaration : jack/midiport.h:68</i>
	 */
	@Mangling({"_Z19jack_midi_event_getP17jack_midi_event_tPv8uint32_t", "?jack_midi_event_get@@YAHPA17jack_midi_event_tPAX8uint32_t@Z"}) 
	int jack_midi_event_get(jack_midi_event_t event, Pointer port_buffer, int event_index);
	/**
	 * Clear an event buffer.<br>
	 * * This should be called at the beginning of each process cycle before calling<br>
	 * @ref jack_midi_event_reserve or @ref jack_midi_event_write. This<br>
	 * function may not be called on an input port's buffer.<br>
	 * * @param port_buffer Port buffer to clear (must be an output port buffer).<br>
	 * Original signature : <code>void jack_midi_clear_buffer(void*)</code><br>
	 * <i>native declaration : jack/midiport.h:82</i>
	 */
	@Mangling({"_Z22jack_midi_clear_bufferPv", "?jack_midi_clear_buffer@@YAXPAX@Z"}) 
	void jack_midi_clear_buffer(Pointer port_buffer);
	/**
	 * Get the size of the largest event that can be stored by the port.<br>
	 * * This function returns the current space available, taking into account<br>
	 * events already stored in the port.<br>
	 * * @param port_buffer Port buffer to check size of.<br>
	 * Original signature : <code>size_t jack_midi_max_event_size(void*)</code><br>
	 * <i>native declaration : jack/midiport.h:93</i>
	 */
	@Mangling({"_Z24jack_midi_max_event_sizePv", "?jack_midi_max_event_size@@YA6size_tPAX@Z"}) 
	NativeSize jack_midi_max_event_size(Pointer port_buffer);
	/**
	 * Allocate space for an event to be written to an event port buffer.<br>
	 * * Clients are to write the actual event data to be written starting at the<br>
	 * pointer returned by this function. Clients must not write more than<br>
	 * @a data_size bytes into this buffer.  Clients must write normalised<br>
	 * MIDI data to the port - no running status and no (1-byte) realtime<br>
	 * messages interspersed with other messages (realtime messages are fine<br>
	 * when they occur on their own, like other messages).<br>
	 * * Events must be written in order, sorted by their sample offsets.<br>
	 * JACK will not sort the events for you, and will refuse to store<br>
	 * out-of-order events.<br>
	 * * @param port_buffer Buffer to write event to.<br>
	 * @param time Sample offset of event.<br>
	 * @param data_size Length of event's raw data in bytes.<br>
	 * @return Pointer to the beginning of the reserved event's data buffer, or<br>
	 * NULL on error (ie not enough space).<br>
	 * Original signature : <code>jack_midi_data_t* jack_midi_event_reserve(void*, uint32_t, size_t)</code><br>
	 * <i>native declaration : jack/midiport.h:116</i>
	 */
	@Mangling({"_Z23jack_midi_event_reservePv8uint32_t6size_t", "?jack_midi_event_reserve@@YAPAEPAX8uint32_t6size_t@Z"}) 
	Pointer jack_midi_event_reserve(Pointer port_buffer, int time, NativeSize data_size);
	/**
	 * Write an event into an event port buffer.<br>
	 * * This function is simply a wrapper for @ref jack_midi_event_reserve<br>
	 * which writes the event data into the space reserved in the buffer.<br>
	 * * Clients must not write more than<br>
	 * @a data_size bytes into this buffer.  Clients must write normalised<br>
	 * MIDI data to the port - no running status and no (1-byte) realtime<br>
	 * messages interspersed with other messages (realtime messages are fine<br>
	 * when they occur on their own, like other messages).<br>
	 * * Events must be written in order, sorted by their sample offsets.<br>
	 * JACK will not sort the events for you, and will refuse to store<br>
	 * out-of-order events.<br>
	 * * @param port_buffer Buffer to write event to.<br>
	 * @param time Sample offset of event.<br>
	 * @param data Message data to be written.<br>
	 * @param data_size Length of @a data in bytes.<br>
	 * @return 0 on success, ENOBUFS if there's not enough space in buffer for event.<br>
	 * Original signature : <code>int jack_midi_event_write(void*, uint32_t, const jack_midi_data_t*, size_t)</code><br>
	 * <i>native declaration : jack/midiport.h:143</i><br>
	 * @deprecated use the safer methods {@link #jack_midi_event_write(com.sun.jna.Pointer, int, java.nio.ByteBuffer, com.ochafik.lang.jnaerator.runtime.NativeSize)} and {@link #jack_midi_event_write(com.sun.jna.Pointer, int, com.sun.jna.Pointer, com.ochafik.lang.jnaerator.runtime.NativeSize)} instead
	 */
	@Mangling({"_Z21jack_midi_event_writePv8uint32_tPKh6size_t", "?jack_midi_event_write@@YAHPAX8uint32_tPAE6size_t@Z"}) 
	@Deprecated 
	int jack_midi_event_write(Pointer port_buffer, int time, Pointer data, NativeSize data_size);
	/**
	 * Write an event into an event port buffer.<br>
	 * * This function is simply a wrapper for @ref jack_midi_event_reserve<br>
	 * which writes the event data into the space reserved in the buffer.<br>
	 * * Clients must not write more than<br>
	 * @a data_size bytes into this buffer.  Clients must write normalised<br>
	 * MIDI data to the port - no running status and no (1-byte) realtime<br>
	 * messages interspersed with other messages (realtime messages are fine<br>
	 * when they occur on their own, like other messages).<br>
	 * * Events must be written in order, sorted by their sample offsets.<br>
	 * JACK will not sort the events for you, and will refuse to store<br>
	 * out-of-order events.<br>
	 * * @param port_buffer Buffer to write event to.<br>
	 * @param time Sample offset of event.<br>
	 * @param data Message data to be written.<br>
	 * @param data_size Length of @a data in bytes.<br>
	 * @return 0 on success, ENOBUFS if there's not enough space in buffer for event.<br>
	 * Original signature : <code>int jack_midi_event_write(void*, uint32_t, const jack_midi_data_t*, size_t)</code><br>
	 * <i>native declaration : jack/midiport.h:143</i>
	 */
	@Mangling({"_Z21jack_midi_event_writePv8uint32_tPKh6size_t", "?jack_midi_event_write@@YAHPAX8uint32_tPAE6size_t@Z"}) 
	int jack_midi_event_write(Pointer port_buffer, int time, ByteBuffer data, NativeSize data_size);
	/**
	 * Get the number of events that could not be written to @a port_buffer.<br>
	 * * This function returning a non-zero value implies @a port_buffer is full.<br>
	 * Currently the only way this can happen is if events are lost on port mixdown.<br>
	 * * @param port_buffer Port to receive count for.<br>
	 * @returns Number of events that could not be written to @a port_buffer.<br>
	 * Original signature : <code>uint32_t jack_midi_get_lost_event_count(void*)</code><br>
	 * <i>native declaration : jack/midiport.h:158</i>
	 */
	@Mangling({"_Z30jack_midi_get_lost_event_countPv", "?jack_midi_get_lost_event_count@@YA8uint32_tPAX@Z"}) 
	int jack_midi_get_lost_event_count(Pointer port_buffer);
	/**
	 * Tell the JACK server to call @a session_callback when a session event<br>
	 * is to be delivered.<br>
	 * * setting more than one session_callback per process is probably a design<br>
	 * error. if you have a multiclient application its more sensible to create<br>
	 * a jack_client with only a session callback set.<br>
	 * * @return 0 on success, otherwise a non-zero error code<br>
	 * Original signature : <code>int jack_set_session_callback(jack_client_t*, JackSessionCallback, void*)</code><br>
	 * <i>native declaration : jack/session.h:172</i>
	 */
	@Mangling({"_Z25jack_set_session_callbackP12_jack_clientPFvP19_jack_session_eventPvEPv", "?jack_set_session_callback@@YAHPA12_jack_clientPFXPA19_jack_session_eventPAX@EPAX@Z"}) 
	int jack_set_session_callback(Pointer client, JackLibrary.JackSessionCallback session_callback, Pointer arg);
	/**
	 * Reply to a session event.<br>
	 * * This can either be called directly from the callback, or later from a<br>
	 * different thread.  For example, it is possible to push the event through a<br>
	 * queue and execute the save code from the GUI thread.<br>
	 * * @return 0 on success, otherwise a non-zero error code<br>
	 * Original signature : <code>int jack_session_reply(jack_client_t*, jack_session_event_t*)</code><br>
	 * <i>native declaration : jack/session.h:185</i>
	 */
	@Mangling({"_Z18jack_session_replyP12_jack_clientP19_jack_session_event", "?jack_session_reply@@YAHPA12_jack_clientPA19_jack_session_event@Z"}) 
	int jack_session_reply(Pointer client, _jack_session_event event);
	/**
	 * free memory used by a jack_session_event_t<br>
	 * this also frees the memory used by the command_line pointer.<br>
	 * if its non NULL.<br>
	 * Original signature : <code>void jack_session_event_free(jack_session_event_t*)</code><br>
	 * <i>native declaration : jack/session.h:194</i>
	 */
	@Mangling({"_Z23jack_session_event_freeP19_jack_session_event", "?jack_session_event_free@@YAXPA19_jack_session_event@Z"}) 
	void jack_session_event_free(_jack_session_event event);
	/**
	 * Original signature : <code>char* jack_client_get_uuid(jack_client_t*)</code><br>
	 * <i>native declaration : jack/session.h:203</i>
	 */
	@Mangling({"_Z20jack_client_get_uuidP12_jack_client", "?jack_client_get_uuid@@YAPADPA12_jack_client@Z"}) 
	Pointer jack_client_get_uuid(Pointer client);
	/**
	 * Send an event to all clients listening for session callbacks.<br>
	 * * The returned strings of the clients are accumulated and returned as an array<br>
	 * of jack_session_command_t. its terminated by ret[i].uuid == NULL target ==<br>
	 * NULL means send to all interested clients. otherwise a clientname<br>
	 * Original signature : <code>jack_session_command_t* jack_session_notify(jack_client_t*, const char*, jack_session_event_type_t, const char*)</code><br>
	 * <i>native declaration : jack/session.h:229</i><br>
	 * @deprecated use the safer methods {@link #jack_session_notify(com.sun.jna.Pointer, java.lang.String, int, java.lang.String)} and {@link #jack_session_notify(com.sun.jna.Pointer, com.sun.jna.Pointer, int, com.sun.jna.Pointer)} instead<br>
	 * @param type @see jack_session_event_type_t
	 */
	@Mangling({"_Z19jack_session_notifyP12_jack_clientPKc25jack_session_event_type_tPKc", "?jack_session_notify@@YAPAUjack_session_command_t@@PA12_jack_clientPAD25jack_session_event_type_tPAD@Z"}) 
	@Deprecated 
	jack_session_command_t jack_session_notify(Pointer client, Pointer target, int type, Pointer path);
	/**
	 * Send an event to all clients listening for session callbacks.<br>
	 * * The returned strings of the clients are accumulated and returned as an array<br>
	 * of jack_session_command_t. its terminated by ret[i].uuid == NULL target ==<br>
	 * NULL means send to all interested clients. otherwise a clientname<br>
	 * Original signature : <code>jack_session_command_t* jack_session_notify(jack_client_t*, const char*, jack_session_event_type_t, const char*)</code><br>
	 * <i>native declaration : jack/session.h:229</i><br>
	 * @param type @see jack_session_event_type_t
	 */
	@Mangling({"_Z19jack_session_notifyP12_jack_clientPKc25jack_session_event_type_tPKc", "?jack_session_notify@@YAPAUjack_session_command_t@@PA12_jack_clientPAD25jack_session_event_type_tPAD@Z"}) 
	jack_session_command_t jack_session_notify(Pointer client, String target, int type, String path);
	/**
	 * Free the memory allocated by a session command.<br>
	 * Original signature : <code>void jack_session_commands_free(jack_session_command_t*)</code><br>
	 * <i>native declaration : jack/session.h:238</i>
	 */
	@Mangling({"_Z26jack_session_commands_freeP22jack_session_command_t", "?jack_session_commands_free@@YAXPAUjack_session_command_t@@@Z"}) 
	void jack_session_commands_free(jack_session_command_t cmds);
	/**
	 * Get the session ID for a client name.<br>
	 * The session manager needs this to reassociate a client name to the session_id.<br>
	 * Original signature : <code>char* jack_get_uuid_for_client_name(jack_client_t*, const char*)</code><br>
	 * <i>native declaration : jack/session.h:244</i><br>
	 * @deprecated use the safer methods {@link #jack_get_uuid_for_client_name(com.sun.jna.Pointer, java.lang.String)} and {@link #jack_get_uuid_for_client_name(com.sun.jna.Pointer, com.sun.jna.Pointer)} instead
	 */
	@Mangling({"_Z29jack_get_uuid_for_client_nameP12_jack_clientPKc", "?jack_get_uuid_for_client_name@@YAPADPA12_jack_clientPAD@Z"}) 
	@Deprecated 
	Pointer jack_get_uuid_for_client_name(Pointer client, Pointer client_name);
	/**
	 * Get the session ID for a client name.<br>
	 * The session manager needs this to reassociate a client name to the session_id.<br>
	 * Original signature : <code>char* jack_get_uuid_for_client_name(jack_client_t*, const char*)</code><br>
	 * <i>native declaration : jack/session.h:244</i>
	 */
	@Mangling({"_Z29jack_get_uuid_for_client_nameP12_jack_clientPKc", "?jack_get_uuid_for_client_name@@YAPADPA12_jack_clientPAD@Z"}) 
	Pointer jack_get_uuid_for_client_name(Pointer client, String client_name);
	/**
	 * Get the client name for a session_id.<br>
	 * * In order to snapshot the graph connections, the session manager needs to map<br>
	 * session_ids to client names.<br>
	 * Original signature : <code>char* jack_get_client_name_by_uuid(jack_client_t*, const char*)</code><br>
	 * <i>native declaration : jack/session.h:253</i><br>
	 * @deprecated use the safer methods {@link #jack_get_client_name_by_uuid(com.sun.jna.Pointer, java.lang.String)} and {@link #jack_get_client_name_by_uuid(com.sun.jna.Pointer, com.sun.jna.Pointer)} instead
	 */
	@Mangling({"_Z28jack_get_client_name_by_uuidP12_jack_clientPKc", "?jack_get_client_name_by_uuid@@YAPADPA12_jack_clientPAD@Z"}) 
	@Deprecated 
	Pointer jack_get_client_name_by_uuid(Pointer client, Pointer client_uuid);
	/**
	 * Get the client name for a session_id.<br>
	 * * In order to snapshot the graph connections, the session manager needs to map<br>
	 * session_ids to client names.<br>
	 * Original signature : <code>char* jack_get_client_name_by_uuid(jack_client_t*, const char*)</code><br>
	 * <i>native declaration : jack/session.h:253</i>
	 */
	@Mangling({"_Z28jack_get_client_name_by_uuidP12_jack_clientPKc", "?jack_get_client_name_by_uuid@@YAPADPA12_jack_clientPAD@Z"}) 
	Pointer jack_get_client_name_by_uuid(Pointer client, String client_uuid);
	/**
	 * Reserve a client name and associate it with a UUID.<br>
	 * * When a client later calls jack_client_open() and specifies the UUID, jackd<br>
	 * will assign the reserved name. This allows a session manager to know in<br>
	 * advance under which client name its managed clients will appear.<br>
	 * * @return 0 on success, otherwise a non-zero error code<br>
	 * Original signature : <code>int jack_reserve_client_name(jack_client_t*, const char*, const char*)</code><br>
	 * <i>native declaration : jack/session.h:265</i><br>
	 * @deprecated use the safer methods {@link #jack_reserve_client_name(com.sun.jna.Pointer, java.lang.String, java.lang.String)} and {@link #jack_reserve_client_name(com.sun.jna.Pointer, com.sun.jna.Pointer, com.sun.jna.Pointer)} instead
	 */
	@Mangling({"_Z24jack_reserve_client_nameP12_jack_clientPKcPKc", "?jack_reserve_client_name@@YAHPA12_jack_clientPADPAD@Z"}) 
	@Deprecated 
	int jack_reserve_client_name(Pointer client, Pointer name, Pointer uuid);
	/**
	 * Reserve a client name and associate it with a UUID.<br>
	 * * When a client later calls jack_client_open() and specifies the UUID, jackd<br>
	 * will assign the reserved name. This allows a session manager to know in<br>
	 * advance under which client name its managed clients will appear.<br>
	 * * @return 0 on success, otherwise a non-zero error code<br>
	 * Original signature : <code>int jack_reserve_client_name(jack_client_t*, const char*, const char*)</code><br>
	 * <i>native declaration : jack/session.h:265</i>
	 */
	@Mangling({"_Z24jack_reserve_client_nameP12_jack_clientPKcPKc", "?jack_reserve_client_name@@YAHPA12_jack_clientPADPAD@Z"}) 
	int jack_reserve_client_name(Pointer client, String name, String uuid);
	/**
	 * Find out whether a client has set up a session callback.<br>
	 * * @return 0 when the client has no session callback, 1 when it has one.<br>
	 *        -1 on error.<br>
	 * Original signature : <code>int jack_client_has_session_callback(jack_client_t*, const char*)</code><br>
	 * <i>native declaration : jack/session.h:276</i><br>
	 * @deprecated use the safer methods {@link #jack_client_has_session_callback(com.sun.jna.Pointer, java.lang.String)} and {@link #jack_client_has_session_callback(com.sun.jna.Pointer, com.sun.jna.Pointer)} instead
	 */
	@Mangling({"_Z32jack_client_has_session_callbackP12_jack_clientPKc", "?jack_client_has_session_callback@@YAHPA12_jack_clientPAD@Z"}) 
	@Deprecated 
	int jack_client_has_session_callback(Pointer client, Pointer client_name);
	/**
	 * Find out whether a client has set up a session callback.<br>
	 * * @return 0 when the client has no session callback, 1 when it has one.<br>
	 *        -1 on error.<br>
	 * Original signature : <code>int jack_client_has_session_callback(jack_client_t*, const char*)</code><br>
	 * <i>native declaration : jack/session.h:276</i>
	 */
	@Mangling({"_Z32jack_client_has_session_callbackP12_jack_clientPKc", "?jack_client_has_session_callback@@YAHPA12_jack_clientPAD@Z"}) 
	int jack_client_has_session_callback(Pointer client, String client_name);
	/**
	 * <i>native declaration : jack/control.h:97</i><br>
	 * Conversion Error : struct __sigset_t {<br>
	 * 	unsigned long int[(1024 / (8 * sizeof(unsigned long int)))] __val;<br>
	 * }
	 */
	/**
	 * <i>native declaration : jack/control.h:106</i><br>
	 * Conversion Error : struct __sigset_t {<br>
	 * 	unsigned long int[(1024 / (8 * sizeof(unsigned long int)))] __val;<br>
	 * }
	 */
	/**
	 * Call this function to create server object.<br>
	 * * @param on_device_acquire - Optional callback to be called before device is acquired. If false is returned, device usage will fail<br>
	 * @param on_device_release - Optional callback to be called after device is released.<br>
	 * * @return server object handle, NULL if creation of server object<br>
	 * failed. Successfully created server object must be destroyed with<br>
	 * paired call to ::jackctl_server_destroy<br>
	 * Original signature : <code>jackctl_server_t* jackctl_server_create(jackctl_server_create_arg1_on_device_acquire_callback, jackctl_server_create_arg2_on_device_release_callback)</code><br>
	 * <i>native declaration : jack/control.h:120</i>
	 */
	Pointer jackctl_server_create(JackLibrary.jackctl_server_create_arg1_on_device_acquire_callback arg1, JackLibrary.jackctl_server_create_arg2_on_device_release_callback arg2);
	/**
	 * Call this function to destroy server object.<br>
	 * * @param server server object handle to destroy<br>
	 * Original signature : <code>void jackctl_server_destroy(jackctl_server_t*)</code><br>
	 * <i>native declaration : jack/control.h:130</i>
	 */
	void jackctl_server_destroy(Pointer server);
	/**
	 * Call this function to open JACK server<br>
	 * * @param server server object handle<br>
	 * @param driver driver to use<br>
	 * * @return success status: true - success, false - fail<br>
	 * Original signature : <code>bool jackctl_server_open(jackctl_server_t*, jackctl_driver_t*)</code><br>
	 * <i>native declaration : jack/control.h:142</i>
	 */
	boolean jackctl_server_open(Pointer server, Pointer driver);
	/**
	 * Call this function to start JACK server<br>
	 * * @param server server object handle<br>
	 * * @return success status: true - success, false - fail<br>
	 * Original signature : <code>bool jackctl_server_start(jackctl_server_t*)</code><br>
	 * <i>native declaration : jack/control.h:154</i>
	 */
	boolean jackctl_server_start(Pointer server);
	/**
	 * Call this function to stop JACK server<br>
	 * * @param server server object handle<br>
	 * * @return success status: true - success, false - fail<br>
	 * Original signature : <code>bool jackctl_server_stop(jackctl_server_t*)</code><br>
	 * <i>native declaration : jack/control.h:165</i>
	 */
	boolean jackctl_server_stop(Pointer server);
	/**
	 * Call this function to close JACK server<br>
	 * * @param server server object handle<br>
	 * * @return success status: true - success, false - fail<br>
	 * Original signature : <code>bool jackctl_server_close(jackctl_server_t*)</code><br>
	 * <i>native declaration : jack/control.h:176</i>
	 */
	boolean jackctl_server_close(Pointer server);
	/**
	 * Call this function to get list of available drivers. List node data<br>
	 * pointers is a driver object handle (::jackctl_driver_t).<br>
	 * * @param server server object handle to get drivers for<br>
	 * * @return Single linked list of driver object handles. Must not be<br>
	 * modified. Always same for same server object.<br>
	 * Original signature : <code>JSList* jackctl_server_get_drivers_list(jackctl_server_t*)</code><br>
	 * <i>native declaration : jack/control.h:189</i>
	 */
	JSList jackctl_server_get_drivers_list(Pointer server);
	/**
	 * Call this function to get list of server parameters. List node data<br>
	 * pointers is a parameter object handle (::jackctl_parameter_t).<br>
	 * * @param server server object handle to get parameters for<br>
	 * * @return Single linked list of parameter object handles. Must not be<br>
	 * modified. Always same for same server object.<br>
	 * Original signature : <code>JSList* jackctl_server_get_parameters(jackctl_server_t*)</code><br>
	 * <i>native declaration : jack/control.h:202</i>
	 */
	JSList jackctl_server_get_parameters(Pointer server);
	/**
	 * Call this function to get list of available internal clients. List node data<br>
	 * pointers is a internal client object handle (::jackctl_internal_t).<br>
	 * * @param server server object handle to get internal clients for<br>
	 * * @return Single linked list of internal client object handles. Must not be<br>
	 * modified. Always same for same server object.<br>
	 * Original signature : <code>JSList* jackctl_server_get_internals_list(jackctl_server_t*)</code><br>
	 * <i>native declaration : jack/control.h:215</i>
	 */
	JSList jackctl_server_get_internals_list(Pointer server);
	/**
	 * Call this function to load one internal client.<br>
	 * (can be used when the server is running)<br>
	 * * @param server server object handle<br>
	 * @param internal internal to use<br>
	 * * @return success status: true - success, false - fail<br>
	 * Original signature : <code>bool jackctl_server_load_internal(jackctl_server_t*, jackctl_internal_t*)</code><br>
	 * <i>native declaration : jack/control.h:228</i>
	 */
	boolean jackctl_server_load_internal(Pointer server, Pointer internal);
	/**
	 * Call this function to unload one internal client.<br>
	 * (can be used when the server is running)<br>
	 * * @param server server object handle<br>
	 * @param internal internal to unload<br>
	 * * @return success status: true - success, false - fail<br>
	 * Original signature : <code>bool jackctl_server_unload_internal(jackctl_server_t*, jackctl_internal_t*)</code><br>
	 * <i>native declaration : jack/control.h:242</i>
	 */
	boolean jackctl_server_unload_internal(Pointer server, Pointer internal);
	/**
	 * Call this function to add a slave in the driver slave list.<br>
	 * (cannot be used when the server is running that is between<br>
	 * jackctl_server_start and jackctl_server_stop)<br>
	 * * @param server server object handle<br>
	 * @param driver driver to add in the driver slave list.<br>
	 * * @return success status: true - success, false - fail<br>
	 * Original signature : <code>bool jackctl_server_add_slave(jackctl_server_t*, jackctl_driver_t*)</code><br>
	 * <i>native declaration : jack/control.h:257</i>
	 */
	boolean jackctl_server_add_slave(Pointer server, Pointer driver);
	/**
	 * Call this function to remove a slave from the driver slave list.<br>
	 * (cannot be used when the server is running that is between<br>
	 * jackctl_server_start and jackctl_server_stop)<br>
	 * * @param server server object handle<br>
	 * @param driver driver to remove from the driver slave list.<br>
	 * * @return success status: true - success, false - fail<br>
	 * Original signature : <code>bool jackctl_server_remove_slave(jackctl_server_t*, jackctl_driver_t*)</code><br>
	 * <i>native declaration : jack/control.h:271</i>
	 */
	boolean jackctl_server_remove_slave(Pointer server, Pointer driver);
	/**
	 * Call this function to switch master driver.<br>
	 * * @param server server object handle<br>
	 * @param driver driver to switch to<br>
	 * * @return success status: true - success, false - fail<br>
	 * Original signature : <code>bool jackctl_server_switch_master(jackctl_server_t*, jackctl_driver_t*)</code><br>
	 * <i>native declaration : jack/control.h:283</i>
	 */
	boolean jackctl_server_switch_master(Pointer server, Pointer driver);
	/**
	 * Call this function to get name of driver.<br>
	 * * @param driver driver object handle to get name of<br>
	 * * @return driver name. Must not be modified. Always same for same<br>
	 * driver object.<br>
	 * Original signature : <code>char* jackctl_driver_get_name(jackctl_driver_t*)</code><br>
	 * <i>native declaration : jack/control.h:296</i>
	 */
	String jackctl_driver_get_name(Pointer driver);
	/**
	 * Call this function to get list of driver parameters. List node data<br>
	 * pointers is a parameter object handle (::jackctl_parameter_t).<br>
	 * * @param driver driver object handle to get parameters for<br>
	 * * @return Single linked list of parameter object handles. Must not be<br>
	 * modified. Always same for same driver object.<br>
	 * Original signature : <code>JSList* jackctl_driver_get_parameters(jackctl_driver_t*)</code><br>
	 * <i>native declaration : jack/control.h:309</i>
	 */
	JSList jackctl_driver_get_parameters(Pointer driver);
	/**
	 * Call this function to get name of internal client.<br>
	 * * @param internal internal object handle to get name of<br>
	 * * @return internal name. Must not be modified. Always same for same<br>
	 * internal object.<br>
	 * Original signature : <code>char* jackctl_internal_get_name(jackctl_internal_t*)</code><br>
	 * <i>native declaration : jack/control.h:321</i>
	 */
	String jackctl_internal_get_name(Pointer internal);
	/**
	 * Call this function to get list of internal parameters. List node data<br>
	 * pointers is a parameter object handle (::jackctl_parameter_t).<br>
	 * * @param internal internal object handle to get parameters for<br>
	 * * @return Single linked list of parameter object handles. Must not be<br>
	 * modified. Always same for same internal object.<br>
	 * Original signature : <code>JSList* jackctl_internal_get_parameters(jackctl_internal_t*)</code><br>
	 * <i>native declaration : jack/control.h:334</i>
	 */
	JSList jackctl_internal_get_parameters(Pointer internal);
	/**
	 * Call this function to get parameter name.<br>
	 * * @param parameter parameter object handle to get name of<br>
	 * * @return parameter name. Must not be modified. Always same for same<br>
	 * parameter object.<br>
	 * Original signature : <code>char* jackctl_parameter_get_name(jackctl_parameter_t*)</code><br>
	 * <i>native declaration : jack/control.h:346</i>
	 */
	String jackctl_parameter_get_name(Pointer parameter);
	/**
	 * Call this function to get parameter short description.<br>
	 * * @param parameter parameter object handle to get short description of<br>
	 * * @return parameter short description. Must not be modified. Always<br>
	 * same for same parameter object.<br>
	 * Original signature : <code>char* jackctl_parameter_get_short_description(jackctl_parameter_t*)</code><br>
	 * <i>native declaration : jack/control.h:358</i>
	 */
	String jackctl_parameter_get_short_description(Pointer parameter);
	/**
	 * Call this function to get parameter long description.<br>
	 * * @param parameter parameter object handle to get long description of<br>
	 * * @return parameter long description. Must not be modified. Always<br>
	 * same for same parameter object.<br>
	 * Original signature : <code>char* jackctl_parameter_get_long_description(jackctl_parameter_t*)</code><br>
	 * <i>native declaration : jack/control.h:370</i>
	 */
	String jackctl_parameter_get_long_description(Pointer parameter);
	/**
	 * Call this function to get parameter type.<br>
	 * * @param parameter parameter object handle to get type of<br>
	 * * @return parameter type. Always same for same parameter object.<br>
	 * Original signature : <code>jackctl_param_type_t jackctl_parameter_get_type(jackctl_parameter_t*)</code><br>
	 * <i>native declaration : jack/control.h:381</i>
	 */
	int jackctl_parameter_get_type(Pointer parameter);
	/**
	 * Call this function to get parameter character.<br>
	 * * @param parameter parameter object handle to get character of<br>
	 * * @return character.<br>
	 * Original signature : <code>char jackctl_parameter_get_id(jackctl_parameter_t*)</code><br>
	 * <i>native declaration : jack/control.h:392</i>
	 */
	byte jackctl_parameter_get_id(Pointer parameter);
	/**
	 * Call this function to check whether parameter has been set, or its<br>
	 * default value is being used.<br>
	 * * @param parameter parameter object handle to check<br>
	 * * @return true - parameter is set, false - parameter is using default<br>
	 * value.<br>
	 * Original signature : <code>bool jackctl_parameter_is_set(jackctl_parameter_t*)</code><br>
	 * <i>native declaration : jack/control.h:405</i>
	 */
	boolean jackctl_parameter_is_set(Pointer parameter);
	/**
	 * Call this function to reset parameter to its default value.<br>
	 * * @param parameter parameter object handle to reset value of<br>
	 * * @return success status: true - success, false - fail<br>
	 * Original signature : <code>bool jackctl_parameter_reset(jackctl_parameter_t*)</code><br>
	 * <i>native declaration : jack/control.h:416</i>
	 */
	boolean jackctl_parameter_reset(Pointer parameter);
	/**
	 * Call this function to get parameter value.<br>
	 * * @param parameter parameter object handle to get value of<br>
	 * * @return parameter value.<br>
	 * Original signature : <code>jackctl_parameter_value jackctl_parameter_get_value(jackctl_parameter_t*)</code><br>
	 * <i>native declaration : jack/control.h:427</i>
	 */
	jackctl_parameter_value.ByValue jackctl_parameter_get_value(Pointer parameter);
	/**
	 * Call this function to set parameter value.<br>
	 * * @param parameter parameter object handle to get value of<br>
	 * @param value_ptr pointer to variable containing parameter value<br>
	 * * @return success status: true - success, false - fail<br>
	 * Original signature : <code>bool jackctl_parameter_set_value(jackctl_parameter_t*, jackctl_parameter_value*)</code><br>
	 * <i>native declaration : jack/control.h:439</i>
	 */
	boolean jackctl_parameter_set_value(Pointer parameter, jackctl_parameter_value value_ptr);
	/**
	 * Call this function to get parameter default value.<br>
	 * * @param parameter parameter object handle to get default value of<br>
	 * * @return parameter default value.<br>
	 * Original signature : <code>jackctl_parameter_value jackctl_parameter_get_default_value(jackctl_parameter_t*)</code><br>
	 * <i>native declaration : jack/control.h:451</i>
	 */
	jackctl_parameter_value.ByValue jackctl_parameter_get_default_value(Pointer parameter);
	/**
	 * Call this function check whether parameter has range constraint.<br>
	 * * @param parameter object handle of parameter to check<br>
	 * * @return whether parameter has range constraint.<br>
	 * Original signature : <code>bool jackctl_parameter_has_range_constraint(jackctl_parameter_t*)</code><br>
	 * <i>native declaration : jack/control.h:462</i>
	 */
	boolean jackctl_parameter_has_range_constraint(Pointer parameter);
	/**
	 * Call this function check whether parameter has enumeration constraint.<br>
	 * * @param parameter object handle of parameter to check<br>
	 * * @return whether parameter has enumeration constraint.<br>
	 * Original signature : <code>bool jackctl_parameter_has_enum_constraint(jackctl_parameter_t*)</code><br>
	 * <i>native declaration : jack/control.h:473</i>
	 */
	boolean jackctl_parameter_has_enum_constraint(Pointer parameter);
	/**
	 * Call this function get how many enumeration values parameter has.<br>
	 * * @param parameter object handle of parameter<br>
	 * * @return number of enumeration values<br>
	 * Original signature : <code>uint32_t jackctl_parameter_get_enum_constraints_count(jackctl_parameter_t*)</code><br>
	 * <i>native declaration : jack/control.h:484</i>
	 */
	int jackctl_parameter_get_enum_constraints_count(Pointer parameter);
	/**
	 * Call this function to get parameter enumeration value.<br>
	 * * @param parameter object handle of parameter<br>
	 * @param index index of parameter enumeration value<br>
	 * * @return enumeration value.<br>
	 * Original signature : <code>jackctl_parameter_value jackctl_parameter_get_enum_constraint_value(jackctl_parameter_t*, uint32_t)</code><br>
	 * <i>native declaration : jack/control.h:496</i>
	 */
	jackctl_parameter_value.ByValue jackctl_parameter_get_enum_constraint_value(Pointer parameter, int index);
	/**
	 * Call this function to get parameter enumeration value description.<br>
	 * * @param parameter object handle of parameter<br>
	 * @param index index of parameter enumeration value<br>
	 * * @return enumeration value description.<br>
	 * Original signature : <code>char* jackctl_parameter_get_enum_constraint_description(jackctl_parameter_t*, uint32_t)</code><br>
	 * <i>native declaration : jack/control.h:509</i>
	 */
	String jackctl_parameter_get_enum_constraint_description(Pointer parameter, int index);
	/**
	 * Call this function to get parameter range.<br>
	 * * @param parameter object handle of parameter<br>
	 * @param min_ptr pointer to variable receiving parameter minimum value<br>
	 * @param max_ptr pointer to variable receiving parameter maximum value<br>
	 * Original signature : <code>void jackctl_parameter_get_range_constraint(jackctl_parameter_t*, jackctl_parameter_value*, jackctl_parameter_value*)</code><br>
	 * <i>native declaration : jack/control.h:521</i>
	 */
	void jackctl_parameter_get_range_constraint(Pointer parameter, jackctl_parameter_value min_ptr, jackctl_parameter_value max_ptr);
	/**
	 * Call this function to check whether parameter constraint is strict,<br>
	 * i.e. whether supplying non-matching value will not work for sure.<br>
	 * * @param parameter parameter object handle to check<br>
	 * * @return whether parameter constraint is strict.<br>
	 * Original signature : <code>bool jackctl_parameter_constraint_is_strict(jackctl_parameter_t*)</code><br>
	 * <i>native declaration : jack/control.h:535</i>
	 */
	boolean jackctl_parameter_constraint_is_strict(Pointer parameter);
	/**
	 * Call this function to check whether parameter has fake values,<br>
	 * i.e. values have no user meaningful meaning and only value<br>
	 * description is meaningful to user.<br>
	 * * @param parameter parameter object handle to check<br>
	 * * @return whether parameter constraint is strict.<br>
	 * Original signature : <code>bool jackctl_parameter_constraint_is_fake_value(jackctl_parameter_t*)</code><br>
	 * <i>native declaration : jack/control.h:548</i>
	 */
	boolean jackctl_parameter_constraint_is_fake_value(Pointer parameter);
	/**
	 * Call this function to log an error message.<br>
	 * * @param format string<br>
	 * Original signature : <code>void jack_error(const char*, null)</code><br>
	 * <i>native declaration : jack/control.h:557</i><br>
	 * @deprecated use the safer methods {@link #jack_error(java.lang.String, java.lang.Object)} and {@link #jack_error(com.sun.jna.Pointer, java.lang.Object)} instead
	 */
	@Deprecated 
	void jack_error(Pointer format, Object... varargs);
	/**
	 * Call this function to log an error message.<br>
	 * * @param format string<br>
	 * Original signature : <code>void jack_error(const char*, null)</code><br>
	 * <i>native declaration : jack/control.h:557</i>
	 */
	void jack_error(String format, Object... varargs);
	/**
	 * Call this function to log an information message.<br>
	 * * @param format string<br>
	 * Original signature : <code>void jack_info(const char*, null)</code><br>
	 * <i>native declaration : jack/control.h:567</i><br>
	 * @deprecated use the safer methods {@link #jack_info(java.lang.String, java.lang.Object)} and {@link #jack_info(com.sun.jna.Pointer, java.lang.Object)} instead
	 */
	@Deprecated 
	void jack_info(Pointer format, Object... varargs);
	/**
	 * Call this function to log an information message.<br>
	 * * @param format string<br>
	 * Original signature : <code>void jack_info(const char*, null)</code><br>
	 * <i>native declaration : jack/control.h:567</i>
	 */
	void jack_info(String format, Object... varargs);
	/**
	 * Call this function to log an information message but only when<br>
	 * verbose mode is enabled.<br>
	 * * @param format string<br>
	 * Original signature : <code>void jack_log(const char*, null)</code><br>
	 * <i>native declaration : jack/control.h:578</i><br>
	 * @deprecated use the safer methods {@link #jack_log(java.lang.String, java.lang.Object)} and {@link #jack_log(com.sun.jna.Pointer, java.lang.Object)} instead
	 */
	@Deprecated 
	void jack_log(Pointer format, Object... varargs);
	/**
	 * Call this function to log an information message but only when<br>
	 * verbose mode is enabled.<br>
	 * * @param format string<br>
	 * Original signature : <code>void jack_log(const char*, null)</code><br>
	 * <i>native declaration : jack/control.h:578</i>
	 */
	void jack_log(String format, Object... varargs);
	/**
	 * Display JACK error message.<br>
	 * * Set via jack_set_error_function(), otherwise a JACK-provided<br>
	 * default will print @a msg (plus a newline) to stderr.<br>
	 * * @param msg error message text (no newline at end).
	 */
	public static final GlobalCallback<jack_error_callback_callback > jack_error_callback = new GlobalCallback<jack_error_callback_callback >(JackLibrary.JNA_NATIVE_LIB, jack_error_callback_callback.class, "jack_error_callback");
	/**
	 * Display JACK info message.<br>
	 * * Set via jack_set_info_function(), otherwise a JACK-provided<br>
	 * default will print @a msg (plus a newline) to stdout.<br>
	 * * @param msg info message text (no newline at end).
	 */
	public static final GlobalCallback<jack_info_callback_callback > jack_info_callback = new GlobalCallback<jack_info_callback_callback >(JackLibrary.JNA_NATIVE_LIB, jack_info_callback_callback.class, "jack_info_callback");
	/// Undefined type
	public static interface jack_native_thread_t {
		
	};
	/// Undefined type
	public static interface jackctl_internal {
		
	};
	/// Undefined type
	public static interface jackctl_parameter {
		
	};
	/// Undefined type
	public static interface jackctl_server {
		
	};
	/// Undefined type
	public static interface _jack_port {
		
	};
	/// Undefined type
	public static interface _jack_client {
		
	};
	/// Undefined type
	public static interface jackctl_driver {
		
	};
}
